<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å°æ²™å½Œå¿ƒç¶“ä¿®ç·´ï¼šå¿ƒç¶“é™é­”</title>
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700;900&family=Zen+Maru+Gothic:wght@500;700&display=swap');

        body {
            font-family: 'Zen Maru Gothic', 'Noto Serif TC', serif;
            background-color: #1a1a1a;
            touch-action: manipulation;
            overflow: hidden;
            color: #4a3b2a;
        }

        .game-wrapper {
            position: relative;
            width: 100%;
            height: 100vh;
            max-width: 500px;
            margin: 0 auto;
            background: linear-gradient(180deg, #87CEEB 0%, #E0F7FA 50%, #FFF8E1 100%);
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        /* èƒŒæ™¯å‹•ç•« */
        .bg-layer {
            position: absolute;
            width: 200%;
            height: 100%;
            background-repeat: repeat-x;
            will-change: transform;
        }
        .scrolling .bg-cloud-1 { animation: scroll 25s linear infinite; }
        .scrolling .bg-cloud-2 { animation: scroll 40s linear infinite; }
        .scrolling .bg-mountain { animation: scroll 60s linear infinite; }
        
        @keyframes scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }

        /* å‹•ç•«é¡åˆ¥ */
        @keyframes walk {
            0% { transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-3px) rotate(2deg); }
            50% { transform: translateY(0) rotate(0deg); }
            75% { transform: translateY(-3px) rotate(-2deg); }
            100% { transform: translateY(0) rotate(0deg); }
        }
        @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        
        /* æ”»æ“Šç‰¹æ•ˆä½ç½® */
        @keyframes shoot-beam {
            0% { left: 20%; opacity: 0; transform: scale(0.5) rotate(0deg); }
            10% { opacity: 1; transform: scale(1.5) rotate(180deg); }
            80% { left: 70%; opacity: 1; transform: scale(1) rotate(720deg); }
            100% { left: 80%; opacity: 0; transform: scale(2); }
        }
        .beam-attack {
            position: absolute;
            left: 20%;
            top: 35%; 
            font-size: 3rem;
            color: #FFD700;
            text-shadow: 0 0 20px #FF8C00;
            z-index: 30;
            animation: shoot-beam 0.6s ease-in forwards;
        }

        /* ä½›è™Ÿå¤§æ‹›ç‰¹æ•ˆ - ä½ç½®ä¿®æ­£ (å®Œå…¨ä¸æ“‹å°æ²™å½Œ) */
        @keyframes mantra-pop {
            0% { transform: scale(0.5) translateY(20px); opacity: 0; }
            50% { transform: scale(1.5) translateY(0); opacity: 1; }
            100% { transform: scale(2) translateY(-20px); opacity: 0; }
        }
        .mantra-effect {
            position: absolute;
            left: 2%;  /* é å·¦é‚Šç·£ */
            bottom: 75%; /* æé«˜ä½ç½®ï¼Œä½æ–¼å°æ²™å½Œé ­é ‚ä¸Šæ–¹ */
            font-size: 4rem;
            color: #FFD700;
            font-weight: 900;
            text-shadow: 0 0 30px #FFD700, 0 0 10px #FFFFFF;
            z-index: 40;
            animation: mantra-pop 1.5s ease-out forwards;
            pointer-events: none;
        }

        /* æ™‚é–“åˆ°æ–‡å­—ç‰¹æ•ˆ */
        @keyframes timeout-pop {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        .timeout-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* ç¢ºä¿çµ•å°ç½®ä¸­ */
            font-size: 4rem;
            font-weight: 900;
            color: #EF4444;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 20px 40px;
            border: 6px solid #EF4444;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 100; /* æœ€é«˜å±¤ç´š */
            animation: timeout-pop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            white-space: nowrap;
            pointer-events: none;
        }

        /* é£„æµ®æ‰£è¡€æ–‡å­—ç‰¹æ•ˆ */
        @keyframes float-up-fade {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
        }
        .floating-text {
            position: absolute;
            font-weight: 900;
            z-index: 50;
            text-shadow: 1px 1px 0 #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff;
            animation: float-up-fade 0.8s ease-out forwards;
            pointer-events: none;
        }

        @keyframes shake-heavy {
            0% { transform: translate(0, 0) rotate(0); }
            10% { transform: translate(-5px, -5px) rotate(-2deg); }
            20% { transform: translate(5px, 5px) rotate(2deg); }
            30% { transform: translate(-5px, 5px) rotate(-2deg); }
            40% { transform: translate(5px, -5px) rotate(2deg); }
            50% { transform: translate(0, 0) rotate(0); }
        }
        .shake-screen { animation: shake-heavy 0.5s cubic-bezier(.36,.07,.19,.97) both; }

        .particle {
            position: absolute;
            pointer-events: none;
            animation: particle-fly 0.8s ease-out forwards;
            border-radius: 50%;
        }
        @keyframes particle-fly {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
        }

        .ult-ready {
            box-shadow: 0 0 20px #FFD700, inset 0 0 20px #FFD700;
            animation: pulse-gold 1s infinite;
        }
        @keyframes pulse-gold {
            0% { box-shadow: 0 0 10px #FFD700; }
            50% { box-shadow: 0 0 30px #FFD700, 0 0 50px #FFA500; }
            100% { box-shadow: 0 0 10px #FFD700; }
        }
        
        @keyframes holy-light {
            0% { background-color: rgba(255, 215, 0, 0); }
            50% { background-color: rgba(255, 255, 255, 0.9); }
            100% { background-color: rgba(255, 215, 0, 0); }
        }
        .flash-screen {
            position: absolute;
            inset: 0;
            z-index: 100;
            pointer-events: none;
            animation: holy-light 0.5s ease-out;
        }
    </style>
</head>
<body>

<div id="root"></div>

<script type="text/babel">

// --- è³‡æº ---
const ASSETS = {
    player: "https://jamiejenjen0305.github.io/MED/littlemonk_1.png",
    enemy_purple: "https://jamiejenjen0305.github.io/MED/monster_p.png",
    enemy_green: "https://jamiejenjen0305.github.io/MED/monster_green.png",
    enemy_red: "https://jamiejenjen0305.github.io/MED/monster_red.png",
    boss: "https://api.dicebear.com/9.x/bottts/png?seed=Willow&backgroundColor=ffab91&size=256"
};

// --- è³‡æ–™åº« ---
const FILL_DATA = {
    level1: [ // å¡«1å­—
        { key: 'avalokita', q: "__è‡ªåœ¨è©è–©ï¼Œè¡Œæ·±èˆ¬è‹¥æ³¢ç¾…èœœå¤šæ™‚", a: "è§€", options: ["è§€", "é—œ", "å®˜", "å…‰"] },
        { key: 'skandhas', q: "ç…§è¦‹äº”è˜Šçš†__ï¼Œåº¦ä¸€åˆ‡è‹¦å„", a: "ç©º", options: ["ç©º", "å‡¶", "å­”", "æ§"] },
        { key: 'sariputra', q: "èˆåˆ©å­ï¼Œæ˜¯è«¸æ³•__ç›¸", a: "ç©º", options: ["ç©º", "æ", "å…¬", "æ”»"] },
        { key: 'form_void', q: "è‰²ä¸ç•°ç©ºï¼Œç©ºä¸ç•°__", a: "è‰²", options: ["è‰²", "æ¾€", "å°„", "è¨­"] },
        { key: 'form_is_void_1', q: "è‰²å³æ˜¯ç©ºï¼Œç©ºå³æ˜¯__", a: "è‰²", options: ["è‰²", "å—", "æƒ³", "è­˜"] },
        { key: 'feeling', q: "å—æƒ³è¡Œè­˜ï¼Œäº¦å¾©å¦‚__", a: "æ˜¯", options: ["æ˜¯", "äº‹", "ä¸–", "å¼"] },
        { key: 'no_birth', q: "ä¸ç”Ÿä¸æ»…ï¼Œä¸å¢ä¸__ï¼Œä¸å¢ä¸æ¸›", a: "æ·¨", options: ["æ·¨", "é€²", "è¿‘", "æ•¬"] },
        { key: 'no_eyes_1', q: "ç„¡çœ¼ç•Œï¼Œä¹ƒè‡³ç„¡__è­˜ç•Œ", a: "æ„", options: ["æ„", "ç•°", "ç¾©", "æ†¶"] },
        { key: 'four_truths_1', q: "ç„¡è‹¦é›†æ»…__", a: "é“", options: ["é“", "åˆ°", "å°", "ç›œ"] },
        { key: 'no_wisdom_1', q: "ç„¡æ™ºäº¦ç„¡__", a: "å¾—", options: ["å¾—", "å¾·", "çš„", "åœ°"] },
        { key: 'no_attainment_1', q: "ä»¥ç„¡æ‰€__æ•…", a: "å¾—", options: ["å¾—", "æœ‰", "æ±‚", "ç¤™"] },
        { key: 'dream_1', q: "é é›¢é¡›å€’å¤¢__", a: "æƒ³", options: ["æƒ³", "ç›¸", "å‘", "è±¡"] },
        { key: 'buddhas_1', q: "ä¸‰ä¸–è«¸__", a: "ä½›", options: ["ä½›", "æ³•", "åƒ§", "å¤©"] },
        { key: 'mantra_great', q: "æ•…çŸ¥èˆ¬è‹¥æ³¢ç¾…èœœå¤šï¼Œæ˜¯å¤§__å’’", a: "ç¥", options: ["ç¥", "ä½›", "é¬¼", "äºº"] },
        { key: 'unequalled_1', q: "æ˜¯ç„¡ç­‰ç­‰__", a: "å’’", options: ["å’’", "æ³•", "ç¶“", "è«–"] },
        { key: 'remove_suffering', q: "èƒ½é™¤ä¸€åˆ‡__ï¼ŒçœŸå¯¦ä¸è™›", a: "è‹¦", options: ["è‹¦", "é›£", "ç½", "å„"] },
        { key: 'say_mantra_1', q: "å³èªªå’’__", a: "æ›°", options: ["æ›°", "æ—¥", "ç›®", "ç™½"] },
        { key: 'gate', q: "æ­è«¦æ­è«¦ï¼Œæ³¢ç¾…__è«¦", a: "æ­", options: ["æ­", "æ¥", "çµ", "è§£"] },
        { key: 'svaha_1', q: "è©æè–©å©†__", a: "è¨¶", options: ["è¨¶", "å‘µ", "æ²³", "è·"] }
    ],
    level2: [ // å¡«2å­—
        { key: 'skandhas_2', q: "ç…§è¦‹äº”è˜Š__ï¼Œåº¦ä¸€åˆ‡è‹¦å„", a: "çš†ç©º", options: ["çš†ç©º", "çš†è‰²", "çš†è‹¦", "çš†ç„¡"] },
        { key: 'sariputra_2', q: "èˆåˆ©å­ï¼Œæ˜¯è«¸æ³•__", a: "ç©ºç›¸", options: ["ç©ºç›¸", "å¯¦ç›¸", "æ³•ç›¸", "ç„¡ç›¸"] },
        { key: 'form_void_2', q: "è‰²å³æ˜¯ç©ºï¼Œç©ºå³__", a: "æ˜¯è‰²", options: ["æ˜¯è‰²", "æ˜¯ç©º", "æ˜¯å—", "æ˜¯æƒ³"] },
        { key: 'feeling_2', q: "å—æƒ³è¡Œè­˜ï¼Œäº¦å¾©__", a: "å¦‚æ˜¯", options: ["å¦‚æ˜¯", "å¦‚æ­¤", "å¦‚å¹»", "å¦‚å¤¢"] },
        { key: 'no_birth_2', q: "ä¸ç”Ÿä¸æ»…ï¼Œä¸å¢__ï¼Œä¸å¢ä¸æ¸›", a: "ä¸æ·¨", options: ["ä¸æ·¨", "ä¸æ¸›", "ä¸å¢", "ä¸ç”Ÿ"] },
        { key: 'senses_2', q: "ç„¡çœ¼è€³__èº«æ„ï¼Œç„¡è‰²è²é¦™å‘³è§¸æ³•", a: "é¼»èˆŒ", options: ["é¼»èˆŒ", "èº«æ„", "æ‰‹è¶³", "å£é¼»"] },
        { key: 'senses_2b', q: "ç„¡çœ¼è€³é¼»èˆŒèº«æ„ï¼Œç„¡è‰²è²__è§¸æ³•", a: "é¦™å‘³", options: ["é¦™å‘³", "è§¸æ³•", "è²é¦™", "å‘³è§¸"] },
        { key: 'ignorance_2', q: "ç„¡ç„¡æ˜ï¼Œäº¦ç„¡__ç›¡", a: "ç„¡æ˜", options: ["ç„¡æ˜", "è€æ­»", "ç›¡æ»…", "æ‰€å¾—"] },
        { key: 'no_fear_2', q: "å¿ƒç„¡ç½£ç¤™ï¼Œç„¡__æ•…", a: "ç½£ç¤™", options: ["ç½£ç¤™", "ææ€–", "å¤¢æƒ³", "éšœç¤™"] },
        { key: 'no_fear_3', q: "å¿ƒç„¡ç½£ç¤™ï¼Œç„¡ç½£__", a: "ç¤™æ•…", options: ["ç¤™æ•…", "ç¤™è‹¦", "ç¤™ç©º", "ç¤™è‰²"] },
        { key: 'dream_2', q: "é é›¢__å¤¢æƒ³ï¼Œç©¶ç«Ÿæ¶…æ§ƒ", a: "é¡›å€’", options: ["é¡›å€’", "å¤¢æƒ³", "ææ€–", "ç½£ç¤™"] },
        { key: 'nirvana_2', q: "é é›¢é¡›å€’å¤¢æƒ³ï¼Œç©¶ç«Ÿ__", a: "æ¶…æ§ƒ", options: ["æ¶…æ§ƒ", "è§£è„«", "åœ“æ»¿", "æˆä½›"] },
        { key: 'no_death_2', q: "ä¹ƒè‡³ç„¡è€æ­»ï¼Œäº¦ç„¡__ç›¡", a: "è€æ­»", options: ["è€æ­»", "ç—…æ­»", "ç”Ÿæ­»", "è‹¦æ­»"] },
        { key: 'mantra_bright', q: "æ˜¯å¤§æ˜å’’ï¼Œæ˜¯__å’’", a: "ç„¡ä¸Š", options: ["ç„¡ä¸Š", "ç„¡ç­‰", "ç¥å’’", "å¤§æ˜"] },
        { key: 'mantra_great_2', q: "æ•…çŸ¥__æ³¢ç¾…èœœå¤š", a: "èˆ¬è‹¥", options: ["èˆ¬è‹¥", "æ™ºæ…§", "åŠŸå¾·", "æ…ˆæ‚²"] },
        { key: 'mantra_unequalled_2', q: "æ˜¯ç„¡ä¸Šå’’ï¼Œæ˜¯ç„¡__å’’", a: "ç­‰ç­‰", options: ["ç­‰ç­‰", "ä¸Šä¸Š", "ä¸‹ä¸‹", "åˆ†åˆ¥"] },
        { key: 'bodhi_sattva', q: "è©æè–©åŸµï¼Œä¾èˆ¬è‹¥__å¯†å¤šæ•…", a: "æ³¢ç¾…", options: ["æ³¢ç¾…", "èœœå¤š", "èˆ¬è‹¥", "æ™ºæ…§"] },
        { key: 'gate_2', q: "æ­è«¦æ­è«¦ï¼Œæ³¢ç¾…__", a: "æ­è«¦", options: ["æ­è«¦", "åƒ§æ­", "æ‘©è¨¶", "èˆ¬è‹¥"] }
    ],
    level3: [ // å¡«4å­—
        { key: 'avalokita_3', q: "è§€è‡ªåœ¨è©è–©ï¼Œè¡Œæ·±__èœœå¤šæ™‚", a: "èˆ¬è‹¥æ³¢ç¾…",   : ["èˆ¬è‹¥æ³¢ç¾…", "æ³¢ç¾…èœœå¤š", "è©æè–©åŸµ", "ä¾èˆ¬è‹¥æ³¢"] },
        { key: 'skandhas_3', q: "__çš†ç©ºï¼Œåº¦ä¸€åˆ‡è‹¦å„", a: "ç…§è¦‹äº”è˜Š", options: ["ç…§è¦‹äº”è˜Š", "äº”è˜Šçš†ç©º", "å—æƒ³è¡Œè­˜", "è‰²å³æ˜¯ç©º"] },
        { key: 'form_void_3', q: "è‰²ä¸ç•°ç©ºï¼Œ__", a: "ç©ºä¸ç•°è‰²", options: ["ç©ºä¸ç•°è‰²", "è‰²å³æ˜¯ç©º", "ç©ºå³æ˜¯è‰²", "å—æƒ³è¡Œè­˜"] },
        { key: 'form_is_void_3', q: "è‰²å³æ˜¯ç©ºï¼Œ__", a: "ç©ºå³æ˜¯è‰²", options: ["ç©ºå³æ˜¯è‰²", "è‰²ä¸ç•°ç©º", "ç©ºä¸ç•°è‰²", "äº¦å¾©å¦‚æ˜¯"] },
        { key: 'feeling_3', q: "__ï¼Œäº¦å¾©å¦‚æ˜¯", a: "å—æƒ³è¡Œè­˜", options: ["å—æƒ³è¡Œè­˜", "è‰²å—æƒ³è¡Œ", "çœ¼è€³é¼»èˆŒ", "è‰²è²é¦™å‘³"] },
        { key: 'sariputra_3', q: "æ˜¯è«¸æ³•ç©ºç›¸ï¼Œ__", a: "ä¸ç”Ÿä¸æ»…", options: ["ä¸ç”Ÿä¸æ»…", "ä¸å¢ä¸æ·¨", "ä¸å¢ä¸æ¸›", "çœŸå¯¦ä¸è™›"] },
        { key: 'no_increase_3', q: "ä¸å¢ä¸æ·¨ï¼Œ__", a: "ä¸å¢ä¸æ¸›", options: ["ä¸å¢ä¸æ¸›", "ä¸ç”Ÿä¸æ»…", "ä¸å¢ä¸æ·¨", "æ˜¯æ•…ç©ºä¸­"] },
        { key: 'senses_3', q: "ç„¡å—æƒ³è¡Œè­˜ï¼Œç„¡__èº«æ„", a: "çœ¼è€³é¼»èˆŒ", options: ["çœ¼è€³é¼»èˆŒ", "èº«æ„ç„¡è‰²", "è‰²è²é¦™å‘³", "è§¸æ³•ç„¡çœ¼"] },
        { key: 'no_eyes_3', q: "ç„¡çœ¼ç•Œï¼Œä¹ƒè‡³__", a: "ç„¡æ„è­˜ç•Œ", options: ["ç„¡æ„è­˜ç•Œ", "ç„¡ç„¡æ˜ç›¡", "ç„¡è€æ­»ç›¡", "ç„¡æ™ºäº¦ç„¡"] },
        { key: 'no_death_3', q: "ä¹ƒè‡³ç„¡è€æ­»ï¼Œ__ç›¡", a: "äº¦ç„¡è€æ­»", options: ["äº¦ç„¡è€æ­»", "ç„¡è€æ­»ç›¡", "ç„¡è‹¦é›†æ»…", "ç„¡æ™ºäº¦ç„¡"] },
        { key: 'no_attainment_3', q: "ç„¡æ™ºäº¦ç„¡å¾—ï¼Œ__æ•…", a: "ä»¥ç„¡æ‰€å¾—", options: ["ä»¥ç„¡æ‰€å¾—", "ç„¡æ‰€å¾—æ•…", "è©æè–©åŸµ", "ä¾èˆ¬è‹¥æ³¢"] },
        { key: 'bodhisattva_3', q: "ä»¥ç„¡æ‰€å¾—æ•…ï¼Œ__", a: "è©æè–©åŸµ", options: ["è©æè–©åŸµ", "ä¾èˆ¬è‹¥æ³¢", "å¿ƒç„¡ç½£ç¤™", "ç„¡ç½£ç¤™æ•…"] },
        { key: 'no_fear_3_long', q: "å¿ƒç„¡ç½£ç¤™ï¼Œ__", a: "ç„¡ç½£ç¤™æ•…", options: ["ç„¡ç½£ç¤™æ•…", "ç„¡æœ‰ææ€–", "é é›¢é¡›å€’", "ç©¶ç«Ÿæ¶…æ§ƒ"] },
        { key: 'dream_3', q: "é é›¢é¡›å€’å¤¢æƒ³ï¼Œ__", a: "ç©¶ç«Ÿæ¶…æ§ƒ", options: ["ç©¶ç«Ÿæ¶…æ§ƒ", "å¿ƒç„¡ç½£ç¤™", "çœŸå¯¦ä¸è™›", "å³èªªå’’æ›°"] },
        { key: 'buddhas_3', q: "ä¸‰ä¸–è«¸ä½›ï¼Œä¾__èœœå¤šæ•…", a: "èˆ¬è‹¥æ³¢ç¾…", options: ["èˆ¬è‹¥æ³¢ç¾…", "æ³¢ç¾…èœœå¤š", "è©æè–©åŸµ", "æ¶…æ§ƒç©¶ç«Ÿ"] },
        { key: 'mantra_3', q: "æ•…çŸ¥èˆ¬è‹¥æ³¢ç¾…èœœå¤šï¼Œ__", a: "æ˜¯å¤§ç¥å’’", options: ["æ˜¯å¤§ç¥å’’", "æ˜¯å¤§æ˜å’’", "æ˜¯ç„¡ä¸Šå’’", "æ˜¯ç„¡ç­‰å’’"] },
        { key: 'truth_3', q: "èƒ½é™¤ä¸€åˆ‡è‹¦ï¼Œ__", a: "çœŸå¯¦ä¸è™›", options: ["çœŸå¯¦ä¸è™›", "çœŸå¯¦ä¸ç©º", "ç©¶ç«Ÿæ¶…æ§ƒ", "æ˜¯ç„¡ä¸Šå’’"] },
        { key: 'say_mantra_3', q: "æ•…èªªèˆ¬è‹¥æ³¢ç¾…èœœå¤šå’’ï¼Œ__", a: "å³èªªå’’æ›°", options: ["å³èªªå’’æ›°", "æ­è«¦æ­è«¦", "æ³¢ç¾…æ­è«¦", "è©æè–©å©†"] },
        { key: 'gate_3', q: "__ï¼Œæ³¢ç¾…åƒ§æ­è«¦", a: "æ³¢ç¾…æ­è«¦", options: ["æ³¢ç¾…æ­è«¦", "æ­è«¦æ­è«¦", "è©æè–©å©†", "æ‘©è¨¶èˆ¬è‹¥"] },
        { key: 'svaha_3', q: "æ³¢ç¾…åƒ§æ­è«¦ï¼Œ__è¨¶", a: "è©æè–©å©†", options: ["è©æè–©å©†", "æ‘©è¨¶èˆ¬è‹¥", "æ³¢ç¾…èœœå¤š", "æ­è«¦æ­è«¦"] }
    ]
};

const ORDER_DATA = [
    ["è§€è‡ªåœ¨è©è–©", "è¡Œæ·±èˆ¬è‹¥æ³¢ç¾…èœœå¤šæ™‚", "ç…§è¦‹äº”è˜Šçš†ç©º", "åº¦ä¸€åˆ‡è‹¦å„", "èˆåˆ©å­"],
    ["è‰²ä¸ç•°ç©º", "ç©ºä¸ç•°è‰²", "è‰²å³æ˜¯ç©º", "ç©ºå³æ˜¯è‰²", "å—æƒ³è¡Œè­˜äº¦å¾©å¦‚æ˜¯"],
    ["èˆåˆ©å­æ˜¯è«¸æ³•ç©ºç›¸", "ä¸ç”Ÿä¸æ»…", "ä¸å¢ä¸æ·¨", "ä¸å¢ä¸æ¸›", "æ˜¯æ•…ç©ºä¸­ç„¡è‰²"],
    ["ç„¡å—æƒ³è¡Œè­˜", "ç„¡çœ¼è€³é¼»èˆŒèº«æ„", "ç„¡è‰²è²é¦™å‘³è§¸æ³•", "ç„¡çœ¼ç•Œä¹ƒè‡³ç„¡æ„è­˜ç•Œ", "ç„¡ç„¡æ˜äº¦ç„¡ç„¡æ˜ç›¡"],
    ["ä¹ƒè‡³ç„¡è€æ­»", "äº¦ç„¡è€æ­»ç›¡", "ç„¡è‹¦é›†æ»…é“", "ç„¡æ™ºäº¦ç„¡å¾—", "ä»¥ç„¡æ‰€å¾—æ•…"],
    ["è©æè–©åŸµ", "ä¾èˆ¬è‹¥æ³¢ç¾…èœœå¤šæ•…", "å¿ƒç„¡ç½£ç¤™", "ç„¡ç½£ç¤™æ•…", "ç„¡æœ‰ææ€–"],
    ["é é›¢é¡›å€’å¤¢æƒ³", "ç©¶ç«Ÿæ¶…æ§ƒ", "ä¸‰ä¸–è«¸ä½›", "ä¾èˆ¬è‹¥æ³¢ç¾…èœœå¤šæ•…", "å¾—é˜¿è€¨å¤šç¾…ä¸‰è—ä¸‰è©æ"],
    ["æ•…çŸ¥èˆ¬è‹¥æ³¢ç¾…èœœå¤š", "æ˜¯å¤§ç¥å’’", "æ˜¯å¤§æ˜å’’", "æ˜¯ç„¡ä¸Šå’’", "æ˜¯ç„¡ç­‰ç­‰å’’"],
    ["èƒ½é™¤ä¸€åˆ‡è‹¦", "çœŸå¯¦ä¸è™›", "æ•…èªªèˆ¬è‹¥æ³¢ç¾…èœœå¤šå’’", "å³èªªå’’æ›°", "æ­è«¦æ­è«¦"],
    ["æ³¢ç¾…æ­è«¦", "æ³¢ç¾…åƒ§æ­è«¦", "è©æè–©å©†è¨¶"]
];

// --- ç²’å­ç³»çµ±çµ„ä»¶ ---
const Particles = ({ items }) => (
    <>
        {items.map(p => (
            <div
                key={p.id}
                className="particle"
                style={{
                    left: p.x, top: p.y, width: p.size, height: p.size,
                    backgroundColor: p.color, '--tx': `${p.tx}px`, '--ty': `${p.ty}px`, zIndex: 40
                }}
            />
        ))}
    </>
);

// --- ä¸»ç¨‹å¼ ---
function App() {
    // ç‹€æ…‹
    const [gameState, setGameState] = React.useState('menu'); 
    const [gameMode, setGameMode] = React.useState(null); 
    const [level, setLevel] = React.useState(1); 
    const [fillDeck, setFillDeck] = React.useState({}); // ç‰Œå †
    const [seenKeys, setSeenKeys] = React.useState(new Set()); // å·²å‡ºç¾éçš„å¥å­ Key
    
    const [playerHP, setPlayerHP] = React.useState(100);
    const [maxHP] = React.useState(100);
    const [progress, setProgress] = React.useState(0); 
    const [score, setScore] = React.useState(0);
    const [enemy, setEnemy] = React.useState(null);
    const [floatingTexts, setFloatingTexts] = React.useState([]); // é£„æµ®æ–‡å­—
    
    // æˆ°é¬¥ç›¸é—œ
    const [fillQuestion, setFillQuestion] = React.useState(null); 
    const [orderTarget, setOrderTarget] = React.useState([]); 
    const [orderCurrent, setOrderCurrent] = React.useState([]); 
    const [orderProgress, setOrderProgress] = React.useState(0); 
    
    const [feedback, setFeedback] = React.useState(null); // 'correct', 'wrong', 'timeout', null
    const [shakeScreen, setShakeScreen] = React.useState(false);
    const [flashScreen, setFlashScreen] = React.useState(false);
    const [combo, setCombo] = React.useState(0);
    const [ultMeter, setUltMeter] = React.useState(0);
    const [particles, setParticles] = React.useState([]);
    const [timer, setTimer] = React.useState(100);
    const [projectile, setProjectile] = React.useState(null); // æ”»æ“Šç‰¹æ•ˆå­—
    const [mantraText, setMantraText] = React.useState(null); // å¤§æ‹›ä½›è™Ÿæ–‡å­—

    // éŸ³æ•ˆæ¨¡æ“¬
    const playSound = (type) => {
        try {
            const file = type === 'correct' ? 'correct.mp3' : 'error.mp3';
            const audio = new Audio(file);
            audio.volume = 0.5; // é¿å…éŸ³é‡éå¤§
            const playPromise = audio.play();
            
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.warn("éŸ³æ•ˆæ’­æ”¾å¤±æ•— (å¯èƒ½æ˜¯ç€è¦½å™¨é˜»æ“‹æˆ–æ‰¾ä¸åˆ°æª”æ¡ˆ):", error);
                });
            }
        } catch (e) {
            console.warn("éŸ³æ•ˆç³»çµ±éŒ¯èª¤:", e);
        }
    };

    const triggerShake = () => { setShakeScreen(true); setTimeout(() => setShakeScreen(false), 500); };
    const triggerFlash = () => { setFlashScreen(true); setTimeout(() => setFlashScreen(false), 500); };
    
    const spawnParticles = (x, y, count, color) => {
        const newParticles = [];
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const v = Math.random() * 100 + 50;
            newParticles.push({
                id: Math.random(), x, y,
                tx: Math.cos(angle) * v, ty: Math.sin(angle) * v,
                size: Math.random() * 8 + 4, color
            });
        }
        setParticles(prev => [...prev, ...newParticles]);
        setTimeout(() => setParticles(prev => prev.slice(count)), 800);
    };

    // æ–°å¢ï¼šé£„æµ®æ–‡å­—ç‰¹æ•ˆå‡½å¼
    const addFloatingText = (x, y, text, color) => {
        const id = Date.now() + Math.random();
        setFloatingTexts(prev => [...prev, { id, x, y, text, color }]);
        setTimeout(() => {
            setFloatingTexts(prev => prev.filter(ft => ft.id !== id));
        }, 800);
    };

    const shuffleArray = (array) => {
        const newArr = [...array];
        for (let i = newArr.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [newArr[i], newArr[j]] = [newArr[j], newArr[i]];
        }
        return newArr;
    };

    // --- éŠæˆ²æµç¨‹æ§åˆ¶ ---

    const initGame = (mode) => {
        setGameMode(mode);
        setGameState('walking');
        setPlayerHP(100);
        setScore(0);
        setCombo(0);
        setUltMeter(0);
        setProgress(0);
        setLevel(1);
        setSeenKeys(new Set()); 
        setFloatingTexts([]);

        // åˆå§‹åŒ–å¡«å­—éŠæˆ²ç‰Œå † (æ´—ç‰Œ)
        if (mode === 'fill') {
            setFillDeck({
                level1: shuffleArray([...FILL_DATA.level1]),
                level2: shuffleArray([...FILL_DATA.level2]),
                level3: shuffleArray([...FILL_DATA.level3])
            });
        }
    };

    React.useEffect(() => {
        let walkTimer;
        if (gameState === 'walking') {
            walkTimer = setTimeout(() => {
                startBattle();
            }, 2000);
        }
        return () => clearTimeout(walkTimer);
    }, [gameState]);

    // Timer Logic - Split into two effects to fix the multiple timeout trigger bug
    React.useEffect(() => {
        if (gameState !== 'battle' || feedback !== null) return;

        const interval = setInterval(() => {
            setTimer(prev => {
                if (prev <= 0) {
                    return 0;
                }
                return prev - 0.2; // ä¿®æ­£ï¼šæ”¾æ…¢é€Ÿåº¦ï¼Œ0.4 -> 0.2ï¼Œæ™‚é–“åŠ å€
            });
        }, 50);

        return () => clearInterval(interval);
    }, [gameState, feedback]);

    // Check for timeout
    React.useEffect(() => {
        if (gameState === 'battle' && feedback === null && timer <= 0) {
            handleTimeOut();
        }
    }, [timer, gameState, feedback]);

    const startBattle = () => {
        setGameState('battle');
        setTimer(100);
        setFeedback(null);
        setOrderProgress(0);

        // æ ¹æ“šé€²åº¦æ±ºå®šæ€ªç‰©é¡è‰² (ç¬¬ä¸€é—œ:ç´«, ç¬¬äºŒé—œ:ç¶ , ç¬¬ä¸‰é—œ:ç´…)
        let enemyColor = 'purple';
        if (progress > 60) enemyColor = 'red';
        else if (progress > 30) enemyColor = 'green';

        setEnemy({
            name: "å¿ƒé­”",
            type: "normal",
            color: enemyColor,
            hp: 1,
            maxHp: 1
        });

        if (gameMode === 'fill') {
            generateFillQuestion();
        } else {
            generateOrderQuestion();
        }
    };

    const generateFillQuestion = () => {
        // é›£åº¦åˆ†ç´š: 0-30: L1, 40-60: L2, 70-100: L3
        let currentLevelKey = 'level1';
        let currentLevelDisplay = 1;
        if (progress > 30) { currentLevelKey = 'level2'; currentLevelDisplay = 2; }
        if (progress > 60) { currentLevelKey = 'level3'; currentLevelDisplay = 3; }
        
        setLevel(currentLevelDisplay);

        let q = null;
        let currentDeck = fillDeck[currentLevelKey];

        // å˜—è©¦å¾ç‰Œå †ä¸­æŠ½å–ã€Œæœªè¦‹é keyã€çš„é¡Œç›®
        if (currentDeck && currentDeck.length > 0) {
            const uniqueIndex = currentDeck.findIndex(item => !seenKeys.has(item.key.split('_')[0])); 
            const targetIndex = uniqueIndex >= 0 ? uniqueIndex : 0;
            q = currentDeck[targetIndex];
            
            const remainingDeck = [...currentDeck];
            remainingDeck.splice(targetIndex, 1);
            
            setFillDeck(prev => ({
                ...prev,
                [currentLevelKey]: remainingDeck
            }));
            setSeenKeys(prev => new Set(prev).add(q.key.split('_')[0]));
        } else {
            const dataset = FILL_DATA[currentLevelKey];
            q = dataset[Math.floor(Math.random() * dataset.length)];
        }

        const opts = shuffleArray(q.options);
        setFillQuestion({ ...q, options: opts });
    };

    const generateOrderQuestion = () => {
        const index = Math.min(Math.floor(progress / 10), ORDER_DATA.length - 1);
        const targetSequence = ORDER_DATA[index];
        const shuffled = shuffleArray(targetSequence);
        
        setOrderTarget(targetSequence);
        setOrderCurrent(shuffled);
        setOrderProgress(0);
        setLevel(index + 1);
    };

    const handleTimeOut = () => {
        playSound('error'); // æ™‚é–“åˆ°æ’­æ”¾éŒ¯èª¤éŸ³æ•ˆ
        triggerShake();
        setFeedback('timeout'); // æ¨™è¨˜ç‚ºæ™‚é–“åˆ°
        setCombo(0); // é€£æ“Šæ­¸é›¶
        
        // ä¿®æ­£ï¼šæ™‚é–“åˆ°é¡¯ç¤ºæ‰£è¡€ç‰¹æ•ˆåœ¨ç©å®¶èº«ä¸Š
        addFloatingText('15%', '45%', '-15', '#EF4444');
        
        const damage = 15;
        setPlayerHP(prev => prev - damage);
        
        if (playerHP - damage <= 0) {
            setTimeout(() => setGameState('gameover'), 1000);
        } else {
            // æ™‚é–“åˆ°ç®—ä¸€é¡Œï¼Œ2ç§’å¾Œæ›ä¸‹ä¸€é¡Œ
            setTimeout(() => {
                setFeedback(null);
                setTimer(100);
                
                // æ ¹æ“šæ¨¡å¼åˆ‡æ›åˆ°ä¸‹ä¸€é¡Œ (æˆ–é‡ç½®æ’åºé¡Œ)
                if (gameMode === 'fill') {
                    generateFillQuestion();
                } else {
                    generateOrderQuestion();
                }
            }, 2000); // å»¶é•·å±•ç¤ºæ™‚é–“åˆ° 2 ç§’
        }
    };

    const handleFillAnswer = (ans) => {
        if (!fillQuestion || feedback) return;
        if (ans === fillQuestion.a) {
            playSound('correct'); // ç­”å°éŸ³æ•ˆ
            setProjectile(ans); // é¡¯ç¤ºæ”»æ“Šå­—
            handleSuccess();
        } else {
            playSound('error'); // ç­”éŒ¯éŸ³æ•ˆ
            handleFail();
        }
    };

    const handleOrderClick = (text, index) => {
        if (feedback === 'wrong') return; 
        const expectedText = orderTarget[orderProgress];
        
        if (text === expectedText) {
            playSound('correct'); // ç­”å°ä¸€å€‹è©éŸ³æ•ˆ
            const nextProgress = orderProgress + 1;
            setOrderProgress(nextProgress);
            setOrderCurrent(prev => prev.map(item => item === text ? null : item));
            spawnParticles('50%', '50%', 10, '#FFD700');
            
            // ä¿®æ­£ï¼šå‹•æ…‹åˆ¤æ–·æ˜¯å¦å®Œæˆè©²çµ„æ‰€æœ‰å¥å­ï¼Œè€Œä¸æ˜¯å¯«æ­» 5
            if (nextProgress >= orderTarget.length) {
                handleSuccess();
            }
        } else {
            playSound('error'); // ç­”éŒ¯éŸ³æ•ˆ
            handleFail();
        }
    };

    const handleSuccess = (isUlt = false) => {
        setFeedback('correct');
        // Update Combo and Score together to ensure consistency
        setCombo(prevCombo => {
            const newCombo = prevCombo + 1;
            setScore(prevScore => prevScore + 100 + (newCombo * 20));
            return newCombo;
        });
        // Update MP (åªæœ‰éå¤§æ‹›è§¸ç™¼æ™‚æ‰å¢åŠ  MP)
        if (!isUlt) {
            setUltMeter(prevMp => Math.min(100, prevMp + 25));
        }
        
        // ä¿®æ­£ï¼šæˆåŠŸæ™‚åœ¨æ€ªç‰©èº«ä¸Šé¡¯ç¤ºæ‰£è¡€ç‰¹æ•ˆ
        addFloatingText('85%', '40%', '-10%', '#EF4444');

        // Visuals
        spawnParticles('80%', '40%', 30, '#FFD700');
        
        setTimeout(() => {
            const nextProgress = progress + 10;
            if (nextProgress >= 100) {
                triggerFlash();
                setGameState('win');
            } else {
                setProjectile(null);
                setMantraText(null); // æ¸…é™¤å¤§æ‹›å­—
                setProgress(nextProgress);
                setGameState('walking');
            }
        }, 1000);
    };

    const handleFail = () => {
        triggerShake();
        setFeedback('wrong');
        setCombo(0);
        setPlayerHP(prev => prev - 10);
        if (playerHP - 10 <= 0) {
            setTimeout(() => setGameState('gameover'), 1000);
        } else {
            setTimeout(() => setFeedback(null), 500);
        }
    };

    const activateUlt = () => {
        if (ultMeter < 100) return;
        triggerFlash();
        setUltMeter(0); // æ¶ˆè€— MPï¼Œæ­¸é›¶
        setProjectile('å'); // ä¿®æ­£ï¼šåŠ å…¥é€™è¡Œï¼Œè®“å¤§æ‹›ç™¼å‹•æ™‚é¡¯ç¤ºã€Œåã€å­—æ”»æ“Š
        playSound('correct'); // å¤§æ‹›ä¹Ÿæ’­æ”¾æ­£ç¢ºéŸ³æ•ˆ
        handleSuccess(true); // å‚³å…¥ true æ¨™è¨˜ç‚ºå¤§æ‹›ï¼Œä¸é‡è¤‡å¢åŠ  MP
    };

    // --- Renders ---
    
    const getPlaceholder = (ans) => 'ï¼Ÿ'.repeat(ans.length);

    const renderMenu = () => (
        <div className="flex flex-col items-center justify-center h-full text-center p-6 space-y-8 z-20 relative">
            <h1 className="text-5xl font-black text-amber-800 tracking-widest drop-shadow-md">å¿ƒç¶“é™é­”</h1>
            <div className="w-40 h-40 animate-bounce">
                <img src={ASSETS.player} className="w-full h-full object-contain filter drop-shadow-xl" />
            </div>
            <div className="grid gap-4 w-full max-w-xs">
                <button onClick={() => initGame('fill')} className="bg-amber-100 border-2 border-amber-400 text-amber-900 text-xl font-bold py-4 rounded-xl shadow-lg active:scale-95 transition flex items-center justify-center gap-2">
                    <span>âœï¸</span> å¡«å­—ä¿®è¡Œ <span className="text-xs bg-amber-600 text-white px-2 py-0.5 rounded-full">3 é—œå¡</span>
                </button>
                <button onClick={() => initGame('order')} className="bg-blue-100 border-2 border-blue-400 text-blue-900 text-xl font-bold py-4 rounded-xl shadow-lg active:scale-95 transition flex items-center justify-center gap-2">
                    <span>ğŸ§©</span> ç¶“æ–‡é‡çµ„ <span className="text-xs bg-blue-600 text-white px-2 py-0.5 rounded-full">æ’æ’çœ‹</span>
                </button>
            </div>
            <div className="absolute bottom-4 text-xs text-amber-800 opacity-60">
                Copyright by JamieJen 2025
            </div>
        </div>
    );

    const renderBattleUI = () => (
        <div className="absolute top-0 left-0 w-full p-4 z-50 pointer-events-none">
            <div className="flex justify-between items-start mb-2">
                <div className="flex flex-col gap-1 w-1/2">
                    <div className="flex items-center gap-2">
                        <span className="text-xs font-bold text-red-600 bg-white/80 px-1 rounded">HP</span>
                        <div className="flex-1 h-3 bg-gray-800/30 rounded-full overflow-hidden border border-white/50">
                            <div className={`h-full transition-all duration-300 ${playerHP<30?'bg-red-500':'bg-green-500'}`} style={{width: `${playerHP}%`}}></div>
                        </div>
                    </div>
                    <div className="flex items-center gap-2">
                        <span className="text-xs font-bold text-yellow-600 bg-white/80 px-1 rounded">MP</span>
                        <div className="flex-1 h-3 bg-gray-800/30 rounded-full overflow-hidden border border-white/50">
                            <div className="h-full bg-yellow-400 transition-all duration-300" style={{width: `${ultMeter}%`}}></div>
                        </div>
                    </div>
                </div>
                <div className="text-right">
                    <div className="text-amber-900 font-black text-xl">{score}</div>
                    {combo > 1 && <div className="text-red-500 font-bold italic animate-pulse">Combo x{combo}</div>}
                </div>
            </div>
            {/* Boss HP Bar */}
            <div className="w-full h-3 bg-gray-800 rounded-full mt-1 border border-gray-600 relative overflow-hidden">
                <div className="h-full bg-gradient-to-r from-purple-600 to-red-600 transition-all duration-1000" style={{width: `${100 - progress}%`}}></div>
            </div>
            <div className="flex justify-between text-xs font-bold text-gray-500 mt-1 px-1">
                <span>{gameMode === 'fill' ? `é›£åº¦ Lv.${level}` : `ç¶“æ–‡æ®µè½ ${level}/10`}</span>
                <span className="text-red-800 font-black">å¿ƒé­” HP {100 - progress}%</span>
            </div>
        </div>
    );

    const renderFillGame = () => (
        <div className="bg-white/95 backdrop-blur-sm rounded-t-[2rem] shadow-[0_-10px_40px_rgba(0,0,0,0.2)] p-6 z-30 border-t border-white/50 absolute bottom-0 w-full">
            <div className="mb-6 text-center">
                <div className="text-sm text-amber-600 font-bold mb-2 uppercase opacity-70">
                    {level === 1 ? "å¡«ä¸€å­—" : level === 2 ? "å¡«äºŒå­—" : "å¡«å››å­—"}
                </div>
                <div className="text-2xl font-serif text-gray-800 font-bold leading-relaxed">
                    {fillQuestion.q.split('__').map((part, i, arr) => (
                        <React.Fragment key={i}>
                            {part}
                            {i < arr.length - 1 && (
                                <span className={`mx-1 inline-block border-b-2 border-amber-500 text-center font-mono ${feedback==='correct'?'text-green-600':'text-amber-300'}`}>
                                    {feedback === 'correct' ? fillQuestion.a : getPlaceholder(fillQuestion.a)}
                                </span>
                            )}
                        </React.Fragment>
                    ))}
                </div>
            </div>
            <div className="grid grid-cols-2 gap-3">
                {fillQuestion.options.map((opt, idx) => (
                    <button key={idx} onClick={() => handleFillAnswer(opt)} disabled={feedback !== null}
                        className={`py-3 rounded-xl text-lg font-bold shadow-md border-b-4 active:scale-95 active:border-b-0 transition ${
                            feedback==='correct'&&opt===fillQuestion.a ? 'bg-green-500 text-white border-green-700' :
                            feedback==='wrong' ? 'bg-gray-200 text-gray-400' : 'bg-amber-100 text-amber-900 border-amber-300'
                        }`}
                    >
                        {opt}
                    </button>
                ))}
            </div>
            <div className="mt-4 h-2 bg-gray-200 rounded-full overflow-hidden"><div className={`h-full ${timer<30?'bg-red-500':'bg-amber-400'} transition-all linear`} style={{width:`${timer}%`}}></div></div>
        </div>
    );

    const renderOrderGame = () => (
        <div className="bg-white/95 backdrop-blur-sm rounded-t-[2rem] shadow-[0_-10px_40px_rgba(0,0,0,0.2)] p-6 z-30 border-t border-white/50 absolute bottom-0 w-full">
            <div className="mb-4">
                <div className="text-sm text-blue-600 font-bold mb-2 text-center">ä¾åºé»æ“Šç¶“æ–‡ (å·²å®Œæˆ: {orderProgress}/5)</div>
                <div className="flex flex-wrap gap-2 justify-center mb-4 min-h-[3rem]">
                    {orderTarget.slice(0, orderProgress).map((txt, i) => (
                        <span key={i} className="bg-blue-100 text-blue-800 px-2 py-1 rounded text-sm font-bold animate-pulse">{txt}</span>
                    ))}
                    {orderProgress < 5 && <span className="border-2 border-dashed border-gray-300 px-4 py-1 rounded text-gray-300 text-sm">?</span>}
                </div>
            </div>
            <div className="flex flex-wrap gap-2 justify-center">
                {orderCurrent.map((opt, idx) => (
                    opt ? (
                        <button key={idx} onClick={() => handleOrderClick(opt, idx)} className="bg-white border-2 border-amber-200 text-amber-900 px-3 py-2 rounded-lg shadow-sm font-medium text-lg active:scale-95 hover:bg-amber-50 transition">{opt}</button>
                    ) : <div key={idx} className="w-20 h-10"></div>
                ))}
            </div>
             <div className="mt-4 h-2 bg-gray-200 rounded-full overflow-hidden"><div className={`h-full ${timer<30?'bg-red-500':'bg-blue-400'} transition-all linear`} style={{width:`${timer}%`}}></div></div>
        </div>
    );

    return (
        <div className={`game-wrapper ${shakeScreen ? 'shake-screen' : ''}`}>
            {flashScreen && <div className="flash-screen"></div>}
            
            <div className={`absolute inset-0 pointer-events-none z-0 ${gameState === 'walking' ? 'scrolling' : ''}`}>
                <div className="absolute inset-0 bg-gradient-to-b from-blue-200 via-purple-100 to-amber-50 opacity-50"></div>
                <div className="bg-layer bg-cloud-2" style={{backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'100\' height=\'100\' viewBox=\'0 0 100 100\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cpath d=\'M10 50 Q 25 30 40 50 T 70 50 T 100 50\' stroke=\'white\' fill=\'none\' stroke-width=\'2\' opacity=\'0.5\'/%3E%3C/svg%3E")', top: '10%'}}></div>
                <div className="bg-layer bg-cloud-1" style={{backgroundImage: 'url("data:image/svg+xml,%3Csvg width=\'200\' height=\'100\' viewBox=\'0 0 200 100\' xmlns=\'http://www.w3.org/2000/svg\'%3E%3Cpath d=\'M0 60 Q 50 20 100 60 T 200 60\' stroke=\'white\' fill=\'white\' opacity=\'0.3\'/%3E%3C/svg%3E")', top: '30%'}}></div>
                <div className="bg-layer bg-mountain" style={{backgroundImage: 'linear-gradient(to bottom, transparent 60%, #c4b595 60%)', bottom: '0', opacity: 0.5}}></div>
            </div>

            {gameState === 'menu' && renderMenu()}
            
            {(gameState === 'walking' || gameState === 'battle') && (
                <>
                    {renderBattleUI()}
                    <div className="flex-1 h-full flex items-center justify-center relative z-10">
                        <Particles items={particles} />
                        {enemy && gameState === 'battle' && (
                            <div className="absolute right-[10%] bottom-[55%] w-48 h-48 flex flex-col items-center animate-float transition-all duration-500">
                                <img src={ASSETS[`enemy_${enemy.color}`]} className="w-full h-full object-contain filter drop-shadow-xl" />
                            </div>
                        )}
                        <div className={`absolute left-[10%] bottom-[50%] w-36 h-36 flex flex-col items-center z-20 ${gameState==='walking'?'animate-[walk_0.8s_infinite]':'animate-float'}`}>
                            {feedback === 'wrong' && <div className="text-red-600 text-4xl font-bold absolute -top-10 animate-bounce">-10</div>}
                            <img src={ASSETS.player} className="w-full h-full object-contain filter drop-shadow-2xl" />
                        </div>
                        {projectile && (
                            <div className="beam-attack font-serif font-black">{projectile}</div>
                        )}
                        {mantraText && (
                            <div className="mantra-effect">{mantraText}</div>
                        )}
                        
                        {/* é£„æµ®æ–‡å­—æ¸²æŸ“å€åŸŸ */}
                        {floatingTexts.map(ft => (
                            <div 
                                key={ft.id}
                                className="floating-text"
                                style={{ 
                                    left: ft.x, 
                                    top: ft.y, 
                                    color: ft.color,
                                    fontSize: '2rem'
                                }}
                            >
                                {ft.text}
                            </div>
                        ))}
                    </div>
                    {/* Time's up overlay - Absolute centered and visible */}
                    {feedback === 'timeout' && (
                        <div className="timeout-text">æ™‚é–“åˆ°ï¼</div>
                    )}

                    {gameState === 'walking' && <div className="absolute bottom-20 w-full text-center z-20"><span className="bg-black/60 text-white px-6 py-2 rounded-full font-bold backdrop-blur-sm animate-pulse">å‰å¾€ä¸‹ä¸€é—œ...</span></div>}

                    {gameState === 'battle' && gameMode === 'fill' && fillQuestion && renderFillGame()}
                    {gameState === 'battle' && gameMode === 'order' && renderOrderGame()}
                    
                    {ultMeter >= 100 && gameState === 'battle' && (
                         <button onClick={activateUlt} className="absolute left-[25%] bottom-[40%] z-50 bg-yellow-400 text-amber-900 rounded-full w-16 h-16 flex items-center justify-center shadow-lg border-4 border-yellow-200 ult-ready active:scale-90 font-black text-2xl animate-bounce">å</button>
                    )}
                </>
            )}

            {gameState === 'gameover' && (
                <div className="absolute inset-0 bg-black/90 text-white flex flex-col items-center justify-center z-50 p-6 text-center">
                    <div className="text-6xl mb-4 grayscale opacity-50">ğŸ’ª</div>
                    <h2 className="text-4xl font-bold mb-2 text-red-500">å†æ¥å†å‹µ</h2>
                    <button onClick={() => setGameState('menu')} className="bg-white text-black font-bold py-3 px-8 rounded-full mt-8 hover:bg-gray-200">è¿”å›ä¸»é¸å–®</button>
                </div>
            )}
            
            {gameState === 'win' && (
                <div className="absolute inset-0 bg-yellow-100 flex flex-col items-center justify-center z-50 p-6 text-center">
                    <div className="text-6xl mb-4 animate-bounce">ğŸ†</div>
                    <h2 className="text-4xl font-bold mb-2 text-amber-800">åŠŸå¾·åœ“æ»¿</h2>
                    <div className="text-2xl mt-4 font-bold text-amber-600">å¾—åˆ†: {score}</div>
                    <button onClick={() => setGameState('menu')} className="bg-amber-600 text-white font-bold py-3 px-8 rounded-full mt-8 shadow-lg">è¿”å›ä¸»é¸å–®</button>
                </div>
            )}
        </div>
    );
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

</script>
</body>
</html>