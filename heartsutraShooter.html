<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>微笑心經：星際大冒險</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Serif+TC:wght@500;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #02010a; /* 更深邃的黑紫底色 */
            font-family: 'Noto Serif TC', serif;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            height: 100%;
            background: #000;
            cursor: none;
            overflow: hidden;
            /* 增加邊緣光暈，更有質感 */
            box-shadow: 0 0 80px rgba(100, 50, 255, 0.2), inset 0 0 100px rgba(0,0,0,0.8);
            border-left: 1px solid rgba(255,255,255,0.1);
            border-right: 1px solid rgba(255,255,255,0.1);
        }

        /* 增加暗角與掃描線效果 */
        #game-container::after {
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            z-index: 8;
        }

        canvas {
            display: block;
            /* 強烈的濾鏡設定，模擬 HDR 效果 */
            filter: contrast(1.2) saturate(1.5) brightness(1.1);
        }

        /* --- 玻璃擬態儀表板 --- */
        #dashboard {
            position: absolute;
            top: 20px; left: 20px; right: 20px;
            height: 85px;
            /* 更通透的玻璃質感 */
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.18);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 25px;
            z-index: 10;
            pointer-events: none;
        }

        /* 進度條容器 */
        #progress-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 24px 24px 0 0;
            overflow: hidden;
        }
        #progress-bar {
            width: 0%; height: 100%;
            /* 流動光影進度條 */
            background: linear-gradient(90deg, #ff6f00, #ffd700, #ff6f00);
            background-size: 200% 100%;
            animation: shimmerBar 2s linear infinite;
            box-shadow: 0 0 15px #ffd700;
            transition: width 0.3s;
        }
        @keyframes shimmerBar { 0% { background-position: 100% 0; } 100% { background-position: -100% 0; } }

        .hud-group {
            display: flex; flex-direction: column; justify-content: center;
        }

        .hud-label {
            font-size: 10px; color: #a0a0ff; text-transform: uppercase; letter-spacing: 2px;
            margin-bottom: 4px; font-weight: bold; text-shadow: 0 0 5px rgba(160, 160, 255, 0.5);
        }

        .hud-value {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 28px; color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.6), 0 0 20px rgba(255, 255, 255, 0.3);
        }

        #score { color: #80d8ff; text-shadow: 0 0 10px #00b0ff; }
        #combo { color: #ff80ab; font-size: 32px; text-shadow: 0 0 10px #ff4081; transition: transform 0.1s; }
        
        #target-group {
            text-align: right;
            border-left: 1px solid rgba(255,255,255,0.15);
            padding-left: 20px;
            min-width: 70px;
        }

        #next-target {
            color: #ffd700; font-size: 44px;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.8), 0 0 30px rgba(255, 111, 0, 0.6);
            animation: pulse-target 1.5s infinite alternate;
        }

        @keyframes pulse-target { from { text-shadow: 0 0 10px #ff6f00; transform: scale(1); } to { text-shadow: 0 0 25px #ffd700; transform: scale(1.1); } }

        #level-display {
            position: absolute; top: 115px; left: 25px;
            font-family: 'Ma Shan Zheng', cursive; font-size: 22px;
            color: #ffd700; text-shadow: 0 0 8px #ff6f00;
            z-index: 9; opacity: 0.9;
            background: rgba(0,0,0,0.5); padding: 4px 12px; border-radius: 12px;
            border: 1px solid rgba(255, 215, 0, 0.3);
        }

        /* --- 遊戲狀態畫面 --- */
        #start-screen, #game-over-screen, #level-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(20,10,40,0.9) 0%, #000 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 20; cursor: default;
            backdrop-filter: blur(10px); padding: 20px; box-sizing: border-box;
        }

        /* 首頁背景動態光輪 */
        #start-screen::before {
            content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 120vw; height: 120vw;
            background: repeating-conic-gradient(from 0deg, rgba(255,215,0,0.05) 0deg, transparent 10deg, rgba(255,215,0,0.05) 20deg);
            border-radius: 50%; animation: rotateBg 60s linear infinite; z-index: -1; pointer-events: none;
        }

        @keyframes rotateBg { from { transform: translate(-50%, -50%) rotate(0deg); } to { transform: translate(-50%, -50%) rotate(360deg); } }

        #level-screen { background: rgba(10, 0, 20, 0.85); display: none; z-index: 15; animation: fadeIn 0.5s; }

        h1 {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: clamp(40px, 12vw, 72px);
            /* 極致流金立體字 */
            background: linear-gradient(180deg, #fff 10%, #ffd700 40%, #ff8f00 60%, #bf360c 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            margin: 0 0 30px 0;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.6)) drop-shadow(0 5px 0 #8f4b0e);
            animation: floatTitle 4s infinite ease-in-out;
            text-align: center; line-height: 1.2; width: 100%;
        }
        @keyframes floatTitle { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

        .btn {
            margin-top: 40px; padding: 16px 56px; font-size: 26px;
            background: linear-gradient(135deg, #7b1fa2, #4a148c);
            color: #ffd700; border: 1px solid rgba(255, 215, 0, 0.6);
            border-radius: 50px; cursor: pointer;
            font-family: 'Ma Shan Zheng', cursive; transition: all 0.3s;
            box-shadow: 0 0 30px rgba(123, 31, 162, 0.5), inset 0 0 10px rgba(255, 255, 255, 0.2);
            white-space: nowrap; letter-spacing: 2px;
            position: relative; overflow: hidden;
        }
        .btn::after {
            content: ''; position: absolute; top: -50%; left: -100%; width: 200%; height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255,255,255,0.4), transparent);
            transform: rotate(45deg); animation: shimmer 3s infinite;
        }
        @keyframes shimmer { 0% { left: -100%; } 100% { left: 200%; } }
        .btn:hover { transform: scale(1.08); box-shadow: 0 0 50px rgba(255, 215, 0, 0.8); color: #fff; border-color: #fff; }

        #collected-sutra {
            position: absolute; bottom: 0; left: 0; width: 100%; height: auto; min-height: 110px; max-height: 180px;
            /* 經文收集區背景更精緻 */
            background: linear-gradient(to top, #1a0510 0%, rgba(40, 10, 30, 0.9) 60%, transparent 100%);
            border-top: 1px solid rgba(255, 215, 0, 0.3);
            display: flex; flex-wrap: wrap; justify-content: center; align-items: flex-end;
            padding: 10px 20px 35px 20px; pointer-events: none; z-index: 5; box-sizing: border-box; overflow: hidden;
            box-shadow: 0 -10px 40px rgba(0,0,0,0.6);
        }

        .sutra-char {
            font-family: 'Ma Shan Zheng', cursive; font-size: 34px; color: #ffd700;
            margin: 0 4px; opacity: 0; display: inline-block;
            transform: translateY(30px) scale(0.5); 
            animation: floatUpChar 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            text-shadow: 0 0 10px rgba(255, 160, 0, 0.8), 0 0 20px rgba(255, 0, 0, 0.4);
        }
        @keyframes floatUpChar { to { opacity: 1; transform: translateY(0) scale(1); } }

        .instruction {
            margin-top: 10px; color: #ccc; font-size: 16px; line-height: 1.8; text-align: center;
            background: rgba(20, 20, 30, 0.7); padding: 18px 28px; border-radius: 16px; 
            width: 85%; max-width: 360px; border: 1px solid rgba(255,255,255,0.15);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .instruction p { margin: 6px 0; }
        .instruction strong { color: #ffca28; text-shadow: 0 0 5px rgba(255, 202, 40, 0.5); }

        /* Boss 血條 */
        #boss-hud {
            position: absolute; top: 110px; left: 50%; transform: translateX(-50%); width: 70%; max-width: 350px;
            display: none; flex-direction: column; align-items: center;
            background: rgba(30, 0, 0, 0.7); padding: 10px 15px; border-radius: 20px;
            border: 1px solid rgba(255, 82, 82, 0.6); backdrop-filter: blur(8px);
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
        }
        #boss-name { font-family: 'Ma Shan Zheng', cursive; color: #ff5252; font-size: 26px; text-shadow: 0 0 15px #b71c1c; margin-bottom: 6px; }
        #boss-hp-bar { width: 100%; height: 8px; background: #222; border-radius: 4px; overflow: hidden; box-shadow: inset 0 0 5px #000; }
        #boss-hp-fill { width: 100%; height: 100%; background: linear-gradient(90deg, #ff1744, #d50000); transition: width 0.2s; box-shadow: 0 0 10px #ff1744; }

        #level-title { font-family: 'Ma Shan Zheng', cursive; font-size: 60px; color: #ffd700; margin-bottom: 15px; text-shadow: 0 0 30px #ff6f00; text-align: center; }
        #level-subtitle { font-family: 'Noto Serif TC', serif; font-size: 24px; color: #eee; letter-spacing: 4px; text-align: center; opacity: 0.9; text-shadow: 0 0 10px rgba(255,255,255,0.5); }
        
        /* 浮動訊息 */
        .floating-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'Ma Shan Zheng', cursive; font-size: 60px; color: #ff4081;
            text-shadow: 0 0 30px rgba(255, 64, 129, 0.9), 0 0 10px #fff; opacity: 0; pointer-events: none;
            animation: floatUp 1.5s cubic-bezier(0.2, 0.8, 0.2, 1); z-index: 100; white-space: nowrap;
        }
        @keyframes floatUp { 
            0% { opacity: 0; transform: translate(-50%, -20%) scale(0.5); } 
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); } 
            100% { opacity: 0; transform: translate(-50%, -100%) scale(1); } 
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="dashboard">
        <div id="progress-container"><div id="progress-bar"></div></div>
        <div class="hud-group">
            <span class="hud-label">功德</span>
            <span class="hud-value" id="score">0</span>
        </div>
        <div class="hud-group" style="align-items: center;">
            <span class="hud-label">連擊</span>
            <span class="hud-value" id="combo">0</span>
        </div>
        <div class="hud-group" id="target-group">
            <span class="hud-label">下一字</span>
            <span class="hud-value" id="next-target">-</span>
        </div>
    </div>
    
    <div id="level-display">第 1 關</div>

    <div id="boss-hud">
        <div id="boss-name">五蘊心魔</div>
        <div id="boss-hp-bar"><div id="boss-hp-fill"></div></div>
    </div>

    <div id="collected-sutra"></div>

    <div id="start-screen">
        <h1>微笑心經：星際大冒險</h1>
        <div class="instruction">
            <p><strong>滑動：</strong>控制木魚移動</p>
            <p><strong>點擊：</strong>發射佛光消除心魔</p>
            <p><strong>Boss：</strong>每 3 關遭遇心魔，消除貪嗔癡</p>
            <p><strong>提醒：</strong>請開啟音效體驗最佳禪意</p>
        </div>
        <button class="btn" id="start-btn">開始修煉</button>
    </div>

    <div id="level-screen">
        <div id="level-title">第 1 關 完成</div>
        <div id="level-subtitle">心無罣礙 繼續前行</div>
    </div>

    <div id="game-over-screen" style="display: none;">
        <h1 id="end-title">修行未果</h1>
        <p id="end-reason" style="font-size: 24px; color: #ff8a80; margin-bottom: 20px;"></p>
        <p class="instruction">最終功德: <span id="final-score">0</span></p>
        <button class="btn" id="restart-btn">重新來過</button>
    </div>
</div>

<audio id="bgm-player" loop src="https://jamiejenjen0305.github.io/MED/meditation-background-434654.mp3"></audio>

<script>
    // --- 3D 風格圖檔生成器 ---
    function createTexture(type, subType) {
        const tmpCanvas = document.createElement('canvas');
        const tmpCtx = tmpCanvas.getContext('2d');
        tmpCanvas.width = 128; tmpCanvas.height = 128;

        if (type === 'player') {
            // 笑臉木魚 (更精緻版)
            // 1. 本體球體光影
            const grad = tmpCtx.createRadialGradient(45, 45, 10, 64, 64, 60);
            grad.addColorStop(0, '#fffde7'); // 極亮黃
            grad.addColorStop(0.3, '#fdd835'); // 中黃
            grad.addColorStop(0.8, '#f57f17'); // 深橘
            grad.addColorStop(1, '#bf360c'); // 邊緣陰影
            
            tmpCtx.shadowColor = 'rgba(255, 160, 0, 0.6)';
            tmpCtx.shadowBlur = 20;
            tmpCtx.fillStyle = grad;
            tmpCtx.beginPath(); tmpCtx.arc(64, 64, 56, 0, Math.PI * 2); tmpCtx.fill();
            
            // 2. 臉部表情 (內陰影刻痕)
            tmpCtx.shadowBlur = 2; tmpCtx.shadowColor = 'rgba(255,255,255,0.5)'; tmpCtx.shadowOffsetY = 2;
            tmpCtx.fillStyle = '#3e2723';
            
            // 眼睛
            tmpCtx.beginPath(); 
            tmpCtx.ellipse(44, 50, 7, 14, 0, 0, Math.PI*2); 
            tmpCtx.ellipse(84, 50, 7, 14, 0, 0, Math.PI*2); tmpCtx.fill();
            
            // 嘴巴
            tmpCtx.lineWidth = 7; tmpCtx.strokeStyle = '#3e2723'; tmpCtx.lineCap = 'round';
            tmpCtx.beginPath(); tmpCtx.arc(64, 70, 26, 0.15 * Math.PI, 0.85 * Math.PI); tmpCtx.stroke();
            
            // 3. 玻璃質感高光 (Reflection)
            tmpCtx.shadowBlur = 0; tmpCtx.shadowOffsetY = 0;
            const highlight = tmpCtx.createLinearGradient(30, 20, 60, 50);
            highlight.addColorStop(0, 'rgba(255,255,255,0.95)'); highlight.addColorStop(1, 'rgba(255,255,255,0.0)');
            tmpCtx.fillStyle = highlight;
            tmpCtx.beginPath(); tmpCtx.ellipse(42, 32, 18, 10, -Math.PI/4, 0, Math.PI*2); tmpCtx.fill();

        } else if (type === 'lotus') {
            // 立體蓮花 (更鮮豔、層次更多)
            const colors = ['#f48fb1', '#ec407a', '#c2185b']; 
            // 蓮花發光
            tmpCtx.shadowColor = '#f50057'; tmpCtx.shadowBlur = 25;
            
            for(let layer=0; layer<3; layer++) {
                // 花瓣漸層
                const petalGrad = tmpCtx.createRadialGradient(64, 64, 10, 64, 64, 60);
                petalGrad.addColorStop(0, '#fce4ec');
                petalGrad.addColorStop(0.5, colors[layer]);
                petalGrad.addColorStop(1, '#880e4f');
                
                tmpCtx.fillStyle = petalGrad;
                tmpCtx.strokeStyle = 'rgba(255,255,255,0.8)'; tmpCtx.lineWidth = 1.5;
                
                const petals = 10 - layer * 2; 
                const radius = 54 - layer * 12; 
                
                for(let i=0; i<petals; i++) {
                    const angle = (i / petals) * Math.PI * 2 + (layer * 0.5); 
                    const cx = 64 + Math.cos(angle) * radius * 0.55;
                    const cy = 64 + Math.sin(angle) * radius * 0.55;
                    
                    tmpCtx.beginPath();
                    tmpCtx.ellipse(cx, cy, 14 - layer*2, radius*0.6, angle, 0, Math.PI*2);
                    tmpCtx.fill(); tmpCtx.stroke();
                }
            }
            // 深紫紅花芯 + 金色花蕊點綴
            const centerGrad = tmpCtx.createRadialGradient(64, 64, 2, 64, 64, 25);
            centerGrad.addColorStop(0, '#ffc107'); centerGrad.addColorStop(0.4, '#ad1457'); centerGrad.addColorStop(1, '#4a0072'); 
            tmpCtx.fillStyle = centerGrad; tmpCtx.beginPath(); tmpCtx.arc(64, 64, 22, 0, Math.PI*2); tmpCtx.fill();
            tmpCtx.strokeStyle = '#ffb74d'; tmpCtx.lineWidth = 2; tmpCtx.stroke();

        } else if (type === 'bullet') {
            // 佛字 (增加光暈層次)
            tmpCtx.font = "bold 80px 'Ma Shan Zheng'"; tmpCtx.textAlign = "center"; tmpCtx.textBaseline = "middle";
            // 外層紅光
            tmpCtx.shadowColor = '#ff3d00'; tmpCtx.shadowBlur = 30; tmpCtx.fillStyle = '#ffeb3b'; tmpCtx.fillText("卍", 64, 68);
            // 內層白光
            tmpCtx.shadowColor = '#fff'; tmpCtx.shadowBlur = 10; tmpCtx.fillStyle = '#ffffff'; tmpCtx.fillText("卍", 64, 68);
        
        } else if (type === 'powerup_spread') {
            // 金蓮
            tmpCtx.shadowColor = '#ffd700'; tmpCtx.shadowBlur = 20; tmpCtx.fillStyle = '#fbc02d';
            for(let i=0; i<8; i++) {
                let angle = i * Math.PI / 4;
                tmpCtx.beginPath(); tmpCtx.ellipse(64 + Math.cos(angle)*30, 64 + Math.sin(angle)*30, 10, 20, angle, 0, Math.PI*2); tmpCtx.fill();
            }
            tmpCtx.beginPath(); tmpCtx.arc(64,64,20,0,Math.PI*2); tmpCtx.fillStyle='#fff9c4'; tmpCtx.fill();
        } else if (type === 'powerup_freeze') {
            // 定
            const grad = tmpCtx.createRadialGradient(64, 64, 10, 64, 64, 50);
            grad.addColorStop(0, '#b9f6ca'); grad.addColorStop(1, '#00bfa5'); // 改為青綠色系
            tmpCtx.fillStyle = grad; tmpCtx.shadowColor = '#1de9b6'; tmpCtx.shadowBlur = 25;
            tmpCtx.beginPath(); tmpCtx.arc(64,64,50,0,Math.PI*2); tmpCtx.fill();
            tmpCtx.fillStyle = '#004d40'; tmpCtx.shadowBlur = 0; tmpCtx.font = "bold 60px 'Ma Shan Zheng'";
            tmpCtx.textAlign="center"; tmpCtx.textBaseline="middle"; tmpCtx.fillText("定", 64, 68);
        }

        return tmpCanvas.toDataURL('image/png');
    }

    // --- 資源 ---
    const playerImg = new Image(); playerImg.src = createTexture('player');
    const lotusImg = new Image(); lotusImg.src = createTexture('lotus'); 
    const bulletImg = new Image(); bulletImg.src = createTexture('bullet');
    const spreadImg = new Image(); spreadImg.src = createTexture('powerup_spread');
    const freezeImg = new Image(); freezeImg.src = createTexture('powerup_freeze');

    const LEVEL_TEXTS = [
        "觀自在菩薩行深般若波羅蜜多時", "照見五蘊皆空度一切苦厄", "舍利子色不異空空不異色", "色即是空空即是色", "受想行識亦復如是",
        "舍利子是諸法空相", "不生不滅不垢不淨不增不減", "是故空中無色無受想行識", "無眼耳鼻舌身意無色聲香味觸法", "無眼界乃至無意識界",
        "無無明亦無無明盡", "乃至無老死亦無老死盡", "無苦集滅道無智亦無得以無所得故", "菩提薩埵依般若波羅蜜多故", "心無罣礙無罣礙故無有恐怖",
        "遠離顛倒夢想究竟涅槃", "三世諸佛依般若波羅蜜多故", "得阿耨多羅三藐三菩提", "故知般若波羅蜜多", "是大神咒是大明咒",
        "是無上咒是無等等咒", "能除一切苦真實不虛", "故說般若波羅蜜多咒即說咒曰", "揭諦揭諦波羅揭諦", "波羅僧揭諦菩提薩婆訶"
    ];

    // --- DOM ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const comboEl = document.getElementById('combo');
    const targetEl = document.getElementById('next-target');
    const levelIndEl = document.getElementById('level-display'); 
    const collectedEl = document.getElementById('collected-sutra');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const levelScreen = document.getElementById('level-screen');
    const levelTitle = document.getElementById('level-title');
    const bossHud = document.getElementById('boss-hud');
    const bossHpFill = document.getElementById('boss-hp-fill');
    const bgmPlayer = document.getElementById('bgm-player');
    const progressBar = document.getElementById('progress-bar');

    // --- 遊戲變數 ---
    let gameState = 'START'; 
    let score = 0;
    let comboCount = 0;
    let currentLevelIndex = 0;
    let currentLevelCharIndex = 0;
    
    const player = { x: 0, y: 0, width: 64, height: 64, targetX: 0, haloAngle: 0, tilt: 0 };
    let hasShield = false;
    let spreadTimer = 0; 
    let freezeTimer = 0; 
    let shakeIntensity = 0;
    let muzzleFlash = 0; 

    let enemies = [];
    let bullets = [];
    let particles = [];
    let floatTexts = []; 
    let items = []; 
    
    let stars = [];
    let nebulas = [];
    let mandalas = []; 
    let spiritDust = []; 
    const STAR_COUNT = 300; // 增加星星數量
    const STAR_SPEED = 2;

    let boss = { active: false, x: 0, y: -200, hp: 100, maxHp: 100, weakPoints: [], attackTimer: 0, defeated: false };
    
    let levelTransitionTimeout = null;

    let lastTime = 0;
    let spawnTimer = 0;
    const spawnInterval = 1500;
    let waveQueue = [];

    // --- 音效 ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    const PENTATONIC_SCALE = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25, 783.99, 880.00, 1046.50];

    function speakText(text) {
        if ('speechSynthesis' in window) {
            window.speechSynthesis.cancel(); 
            let spokenText = text;
            if (text === '般') spokenText = '波'; 
            if (text === '若') spokenText = '惹'; 
            if (text === '子') spokenText = '紫'; 
            if (text === '切') spokenText = '怯'; 
            const utterance = new SpeechSynthesisUtterance(spokenText);
            utterance.lang = 'zh-TW';
            utterance.rate = 1.5; utterance.volume = 1.0;
            window.speechSynthesis.speak(utterance);
        }
    }

    function playSound(type, combo = 0) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;

        if (type === 'hit') {
            osc.type = 'sine';
            let noteIndex = Math.min(combo, PENTATONIC_SCALE.length - 1);
            let freq = PENTATONIC_SCALE[noteIndex];
            osc.frequency.setValueAtTime(freq, now);
            osc.frequency.exponentialRampToValueAtTime(freq, now + 0.1); 
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.start(); osc.stop(now + 0.3);
        } else if (type === 'shoot') {
            osc.type = 'triangle'; 
            osc.frequency.setValueAtTime(spreadTimer > 0 ? 800 : 600, now);
            osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            osc.start(); osc.stop(now + 0.15);
        } else if (type === 'error') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(50, now + 0.3);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
            osc.start(); osc.stop(now + 0.3);
        } else if (type === 'powerup') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(523, now);
            osc.frequency.linearRampToValueAtTime(1046, now + 0.3);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.linearRampToValueAtTime(0.01, now + 0.5);
            osc.start(); osc.stop(now + 0.5);
        } else if (type === 'boss_roar') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(80, now);
            osc.frequency.linearRampToValueAtTime(40, now + 1.0);
            gain.gain.setValueAtTime(0.5, now);
            gain.gain.linearRampToValueAtTime(0.01, now + 1.0);
            osc.start(); osc.stop(now + 1.0);
        }
    }

    function triggerShake(intensity) { shakeIntensity = intensity; }

    function initUniverse() {
        stars = []; nebulas = []; mandalas = []; spiritDust = [];
        
        for (let i = 0; i < STAR_COUNT; i++) {
            stars.push({
                x: (Math.random() - 0.5) * canvas.width * 3, y: (Math.random() - 0.5) * canvas.height * 3,
                z: Math.random() * canvas.width, 
                color: Math.random() > 0.7 ? '#e0f7fa' : '#fff', // 稍微帶點青色
                size: Math.random() * 2 // 大小變化
            });
        }
        for (let i = 0; i < 5; i++) {
            nebulas.push({
                x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: 150 + Math.random() * 250,
                color: `hsla(${Math.random() * 60 + 240}, 80%, 60%, 0.12)`, // 藍紫調更強
                vx: (Math.random() - 0.5) * 0.3, vy: (Math.random() - 0.5) * 0.3
            });
        }
        for (let i = 0; i < 3; i++) {
            mandalas.push({
                x: canvas.width / 2, y: canvas.height / 2 + (Math.random()-0.5)*200, radius: 250 + i * 180,
                points: 8 + i * 4, angle: Math.random() * Math.PI, speed: 0.001 * (i % 2 === 0 ? 1 : -1), opacity: 0.06 + i * 0.02
            });
        }
        for (let i = 0; i < 40; i++) { // 增加粒子
            spiritDust.push({
                x: Math.random() * canvas.width, y: Math.random() * canvas.height, vy: -0.8 - Math.random(), 
                size: Math.random() * 2.5 + 1, opacity: Math.random() * 0.6 + 0.3
            });
        }
    }

    function showFloatingMsg(text, type = 'normal', x, y) {
        const div = document.createElement('div');
        div.className = 'floating-msg'; div.innerText = text;
        const container = document.getElementById('game-container');
        if (x && y) { 
            x = Math.max(0, Math.min(x, container.clientWidth));
            div.style.left = x + 'px'; div.style.top = y + 'px'; 
        }
        if (type === 'golden') { div.style.color = '#ffd700'; div.style.textShadow = '0 0 30px #ffd700'; }
        if (type === 'crit') { div.style.color = '#ff1744'; div.style.fontSize = '40px'; div.innerText = text + "!"; }
        container.appendChild(div);
        setTimeout(() => div.remove(), 1500);
    }

    function resize() {
        const container = document.getElementById('game-container');
        canvas.width = container.clientWidth; canvas.height = container.clientHeight;
        player.y = canvas.height - 110; player.x = canvas.width / 2;
        initUniverse();
    }
    window.addEventListener('resize', resize);
    
    let touchStartX = 0; let touchStartY = 0; let touchStartTime = 0;
    function handleMove(clientX) {
        if (gameState === 'PLAYING' || gameState === 'BOSS') {
            const rect = canvas.getBoundingClientRect();
            player.targetX = clientX - rect.left;
        }
    }
    document.addEventListener('mousemove', (e) => handleMove(e.clientX));
    document.addEventListener('mousedown', (e) => { if (gameState === 'PLAYING' || gameState === 'BOSS') shoot(); });
    canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e.touches[0].clientX); }, { passive: false });
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault(); if (gameState === 'START' || gameState === 'GAMEOVER') return; 
        handleMove(e.touches[0].clientX);
        touchStartX = e.touches[0].clientX; touchStartY = e.touches[0].clientY; touchStartTime = Date.now();
    }, { passive: false });
    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (gameState === 'PLAYING' || gameState === 'BOSS') {
            const touch = e.changedTouches[0];
            const dx = touch.clientX - touchStartX; const dy = touch.clientY - touchStartY;
            if (Math.sqrt(dx*dx + dy*dy) < 30 && (Date.now() - touchStartTime) < 500) shoot();
        }
    }, { passive: false });

    document.getElementById('start-btn').onclick = startGame;
    document.getElementById('start-btn').ontouchend = (e) => { e.preventDefault(); startGame(); }; 
    document.getElementById('restart-btn').onclick = resetToHome;
    document.getElementById('restart-btn').ontouchend = (e) => { e.preventDefault(); resetToHome(); };

    function resetToHome() {
        if (levelTransitionTimeout) clearTimeout(levelTransitionTimeout);
        gameState = 'START';
        gameOverScreen.style.display = 'none'; startScreen.style.display = 'flex'; bossHud.style.display = 'none';
        collectedEl.innerHTML = ''; bgmPlayer.pause(); bgmPlayer.currentTime = 0;
        enemies = []; bullets = []; items = []; floatTexts = []; particles = [];
        waveQueue = []; boss.active = false; score = 0; comboCount = 0; player.x = canvas.width / 2;
    }

    function startGame() {
        score = 0; comboCount = 0; currentLevelIndex = 0;
        hasShield = false; spreadTimer = 0; freezeTimer = 0;
        enemies = []; bullets = []; particles = []; waveQueue = []; items = []; floatTexts = [];
        boss.active = false; boss.defeated = false; bossHud.style.display = 'none';
        scoreEl.innerText = 0; comboEl.innerText = 0; collectedEl.innerHTML = '';
        startScreen.style.display = 'none'; gameOverScreen.style.display = 'none';
        bgmPlayer.play().catch(e => console.log("需使用者互動才能播放音樂"));
        resize(); loadLevel(0); lastTime = performance.now();
    }

    function loadLevel(levelIdx) {
        if (levelIdx >= LEVEL_TEXTS.length) { winGame(); return; }
        currentLevelIndex = levelIdx; currentLevelCharIndex = 0;
        let text = LEVEL_TEXTS[levelIdx];
        waveQueue = text.split('').map((c, i) => ({ char: c, idx: i }));
        boss.defeated = false; 
        levelIndEl.innerText = `第 ${levelIdx + 1} 關`;
        collectedEl.innerHTML = '';
        progressBar.style.width = '0%'; 
        updateTarget(); gameState = 'PLAYING';
    }

    function updateTarget() {
        let text = LEVEL_TEXTS[currentLevelIndex];
        let progress = (currentLevelCharIndex / text.length) * 100;
        progressBar.style.width = progress + '%';
        
        if (currentLevelCharIndex < text.length) {
            targetEl.innerText = text[currentLevelCharIndex];
            targetEl.style.transform = "scale(1.3)";
            setTimeout(() => targetEl.style.transform = "scale(1)", 150);
        } else {
            targetEl.innerText = "完成";
        }
    }

    function levelComplete() {
        if ((currentLevelIndex + 1) % 3 === 0 && !boss.defeated) { spawnBoss(); return; }
        gameState = 'LEVEL_TRANSITION';
        levelTitle.innerText = `第 ${currentLevelIndex + 1} 關 完成`;
        levelScreen.style.display = 'flex';
        levelTransitionTimeout = setTimeout(() => { levelScreen.style.display = 'none'; loadLevel(currentLevelIndex + 1); }, 2000);
    }

    function shoot() {
        playSound('shoot'); muzzleFlash = 5; 
        const createBullet = (angleOffset) => {
            bullets.push({
                x: player.x, y: player.y - 30,
                vx: Math.sin(angleOffset) * 5, vy: -15, width: 32, height: 32, trail: []
            });
        };
        if (comboCount >= 20) { createBullet(0); createBullet(-0.2); createBullet(0.2); } 
        else if (comboCount >= 10) { createBullet(-0.1); createBullet(0.1); } 
        else { createBullet(0); }
        if (spreadTimer > 0) { createBullet(-0.4); createBullet(0.4); }
    }

    function spawnBoss() {
        gameState = 'BOSS'; boss.active = true; boss.x = canvas.width / 2; boss.y = -150; 
        boss.maxHp = 100 + (currentLevelIndex * 10); boss.hp = boss.maxHp;
        boss.weakPoints = [{ text: '貪', x: 0, y: 0, active: true }, { text: '嗔', x: 0, y: 0, active: true }, { text: '癡', x: 0, y: 0, active: true }];
        bossHud.style.display = 'flex'; playSound('boss_roar'); triggerShake(20); showFloatingMsg("心魔現身！", 'normal'); enemies = [];
    }

    function checkBossLogic(dt) {
        if (!boss.active) return;
        if (boss.y < 100) boss.y += 2;
        boss.x = canvas.width/2 + Math.sin(Date.now() * 0.001) * 150;
        const time = Date.now() * 0.002;
        boss.weakPoints.forEach((wp, i) => {
            if (!wp.active) return;
            const angle = time + (i * (Math.PI * 2 / 3));
            wp.x = boss.x + Math.cos(angle) * 100; wp.y = boss.y + Math.sin(angle) * 60;
        });
        boss.attackTimer += dt;
        let attackInterval = Math.max(500, 2000 - currentLevelIndex * 50);
        if (boss.attackTimer > attackInterval) {
            boss.attackTimer = 0;
            for (let k = -2; k <= 2; k++) {
                enemies.push({ x: boss.x, y: boss.y + 50, width: 30, height: 30, type: 'interference_straight', speed: 6, vx: k * 2 });
            }
        }
    }

    function gameLoop(timestamp) {
        const dt = timestamp - lastTime; lastTime = timestamp;
        if (shakeIntensity > 0) shakeIntensity *= 0.9; if (shakeIntensity < 0.5) shakeIntensity = 0;

        ctx.save();
        if (shakeIntensity > 0) ctx.translate((Math.random()-0.5)*shakeIntensity, (Math.random()-0.5)*shakeIntensity);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. 繪製背景
        ctx.save();
        const centerX = canvas.width / 2; const centerY = canvas.height / 2;
        
        ctx.lineWidth = 1;
        mandalas.forEach(m => {
            m.angle += m.speed; ctx.strokeStyle = `rgba(255, 215, 0, ${m.opacity})`; 
            ctx.save(); ctx.translate(centerX, centerY); ctx.rotate(m.angle);
            ctx.beginPath();
            for(let i=0; i<=m.points; i++) {
                const angle = (i / m.points) * Math.PI * 2;
                if(i===0) ctx.moveTo(Math.cos(angle)*m.radius, Math.sin(angle)*m.radius); else ctx.lineTo(Math.cos(angle)*m.radius, Math.sin(angle)*m.radius);
            }
            ctx.closePath(); ctx.stroke(); ctx.restore();
        });

        ctx.globalCompositeOperation = 'lighter'; 
        nebulas.forEach(n => {
            n.x += n.vx; n.y += n.vy;
            if(n.x < -200) n.x = canvas.width+200; if(n.x > canvas.width+200) n.x = -200;
            if(n.y < -200) n.y = canvas.height+200; if(n.y > canvas.height+200) n.y = -200;
            const grad = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.radius);
            grad.addColorStop(0, n.color); grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(n.x, n.y, n.radius, 0, Math.PI*2); ctx.fill();
        });
        
        ctx.globalCompositeOperation = 'source-over';
        stars.forEach(star => {
            let speed = STAR_SPEED + (currentLevelIndex * 0.2); 
            if (currentLevelIndex >= 23) speed = 15; if (comboCount > 20) speed += 5; 
            star.z -= speed;
            if (star.z <= 0) { star.z = canvas.width; star.x = (Math.random() - 0.5) * canvas.width * 3; star.y = (Math.random() - 0.5) * canvas.height * 3; }
            const k = 128.0 / star.z; const px = star.x * k + centerX; const py = star.y * k + centerY;
            if (px >= 0 && px <= canvas.width && py >= 0 && py <= canvas.height) {
                const size = (1 - star.z / canvas.width) * (star.size || 2);
                ctx.fillStyle = star.color; ctx.globalAlpha = (1 - star.z / canvas.width);
                ctx.beginPath(); ctx.arc(px, py, size, 0, Math.PI * 2); ctx.fill();
            }
        });
        ctx.globalAlpha = 1.0;
        
        spiritDust.forEach(d => {
            d.y += d.vy; if (d.y < 0) { d.y = canvas.height; d.x = Math.random() * canvas.width; }
            ctx.fillStyle = `rgba(255, 255, 200, ${d.opacity})`; ctx.beginPath(); ctx.arc(d.x, d.y, d.size, 0, Math.PI*2); ctx.fill();
        });

        if (currentLevelIndex >= 23 || comboCount >= 20) {
            ctx.globalCompositeOperation = 'overlay'; ctx.fillStyle = 'rgba(255, 215, 0, 0.15)';
            ctx.fillRect(0,0,canvas.width, canvas.height); ctx.globalCompositeOperation = 'source-over';
        }
        ctx.restore();

        // 2. 邏輯更新
        if (gameState === 'PLAYING' || gameState === 'BOSS') {
            let diff = player.targetX - player.x;
            player.x += diff * 0.15;
            player.tilt = Math.max(-0.5, Math.min(0.5, diff * 0.01)); 
            player.haloAngle += 0.02;
            if (spreadTimer > 0) spreadTimer -= dt;
            if (freezeTimer > 0) freezeTimer -= dt;
            if (muzzleFlash > 0) muzzleFlash--; 
            if (Math.abs(diff) > 2) particles.push({ x: player.x, y: player.y, size: 30, life: 0.5, color: '#fff176', type: 'trail' });
        }

        // 道具
        for (let i = items.length - 1; i >= 0; i--) {
            let item = items[i]; item.y += 3;
            if (Math.hypot(player.x - item.x, player.y - item.y) < 50) {
                playSound('powerup');
                if (item.type === 'spread') { spreadTimer = 5000; showFloatingMsg("千手觀音!"); }
                else if (item.type === 'freeze') { freezeTimer = 3000; showFloatingMsg("定!"); }
                else if (item.type === 'shield') { hasShield = true; showFloatingMsg("般若盾!"); }
                items.splice(i, 1);
            } else if (item.y > canvas.height) items.splice(i, 1);
        }

        if (gameState === 'BOSS') {
            checkBossLogic(dt);
            if (boss.weakPoints.every(wp => !wp.active) || boss.hp <= 0) {
                boss.active = false; boss.defeated = true; bossHud.style.display = 'none';
                showFloatingMsg("心魔已除！", 'golden'); triggerShake(30); enemies = []; levelComplete(); 
            }
        } 
        else if (gameState === 'PLAYING' && freezeTimer <= 0) {
            spawnTimer += dt;
            let interval = Math.max(400, spawnInterval - (currentLevelIndex * 40)); 
            if (currentLevelIndex >= 23) interval = 200;

            if (spawnTimer > interval) {
                spawnTimer = 0;
                if (waveQueue.length > 0) {
                    const data = waveQueue.shift();
                    const enemyWidth = 70; const margin = canvas.width * 0.15;
                    const spawnX = Math.random() * (canvas.width - margin*2 - enemyWidth) + margin;
                    enemies.push({
                        x: spawnX, y: -50, width: 70, height: 70, type: 'text',
                        char: data.char, idx: data.idx,
                        speed: (canvas.height/15000)*16 * (1 + currentLevelIndex*0.05),
                        wobble: Math.random()*100, angle: 0, rotSpeed: (Math.random()-0.5) * 0.05
                    });
                } else if (enemies.length === 0) { levelComplete(); }
            }
        }

        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            if (freezeTimer <= 0) {
                if (e.type === 'interference_straight') { e.y += e.speed; if (e.vx) e.x += e.vx; } 
                else { e.y += e.speed; if (e.char) e.x += Math.sin((e.y + e.wobble)*0.02)*0.5; }
                if (e.rotSpeed) e.angle += e.rotSpeed; 
            }

            if (e.y + e.height > player.y - 20 && Math.abs(e.x - player.x) < 40) {
                if (hasShield) { hasShield = false; triggerShake(10); playSound('error'); showFloatingMsg("護盾破碎"); enemies.splice(i, 1); } 
                else { gameOver("定力不足，心魔入侵"); return; }
            }
            else if (e.y > canvas.height) {
                if (e.type === 'text') { 
                    e.y = -100; const margin = canvas.width * 0.15;
                    e.x = Math.random() * (canvas.width - margin*2 - 70) + margin;
                    if (currentLevelIndex < 23) { score = Math.max(0, score - 5); comboCount = 0; }
                    scoreEl.innerText = score; comboEl.innerText = comboCount;
                } else { enemies.splice(i, 1); }
            }
        }

        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            b.x += b.vx || 0; b.y += b.vy; b.trail.push({x:b.x, y:b.y}); if(b.trail.length>5) b.trail.shift();
            if (b.y < -50) bullets.splice(i, 1);
        }

        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i]; let hit = false;
            if (gameState === 'BOSS' && boss.active) {
                for (let wp of boss.weakPoints) {
                    if (wp.active && Math.hypot(b.x - wp.x, b.y - wp.y) < 40) {
                        wp.active = false; hit = true; createExplosion(wp.x, wp.y, '#ff5252', true);
                        boss.hp -= 34; bossHpFill.style.width = Math.max(0, (boss.hp/boss.maxHp)*100) + '%';
                        playSound('hit');
                        if (Math.random() > 0.5) items.push({x: wp.x, y: wp.y, type: 'spread'});
                        break;
                    }
                }
            }
            if (!hit) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    let e = enemies[j];
                    if (Math.hypot(b.x - (e.x + 35), b.y - (e.y + 35)) < 40) {
                        hit = true;
                        if (e.type.startsWith('interference')) {
                            createExplosion(e.x+35, e.y+35, '#555', true); enemies.splice(j, 1);
                        } else if (e.idx === currentLevelCharIndex) {
                            comboCount++; playSound('hit', comboCount); score += 100 + (comboCount * 10);
                            speakText(e.char);
                            currentLevelCharIndex++;
                            floatTexts.push({text: e.char, x: e.x, y: e.y, life: 1.0, scale: 1});
                            if (comboCount % 20 === 0) items.push({x: e.x, y: e.y, type: 'spread'});
                            if (comboCount % 35 === 0) items.push({x: e.x, y: e.y, type: 'freeze'});
                            if (comboCount % 10 === 0 && !hasShield) { hasShield = true; showFloatingMsg("般若盾"); }
                            
                            showFloatingMsg("+" + (100 + comboCount*10), 'crit', e.x+35, e.y-20);
                            
                            createExplosion(e.x+35, e.y+35, '#ffd700', true);
                            const span = document.createElement('span'); span.className = 'sutra-char'; span.innerText = e.char; collectedEl.appendChild(span);
                            collectedEl.scrollTop = collectedEl.scrollHeight;
                            enemies.splice(j, 1); updateTarget();
                        } else {
                            if (currentLevelIndex < 23) {
                                comboCount = 0; score -= 10; playSound('error'); triggerShake(5);
                                createExplosion(e.x+35, e.y+35, '#ff5252', false);
                            } else {
                                createExplosion(e.x+35, e.y+35, '#ffd700', false); enemies.splice(j, 1);
                            }
                        }
                        scoreEl.innerText = score; comboEl.innerText = comboCount;
                        break;
                    }
                }
            }
            if (hit) bullets.splice(i, 1);
        }

        // 3. 繪製物件
        if (gameState !== 'START') {
            items.forEach(item => { ctx.drawImage((item.type === 'spread') ? spreadImg : freezeImg, item.x-20, item.y-20, 40, 40); });

            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.haloAngle + player.tilt); ctx.scale(1 - Math.abs(player.tilt)*0.2, 1); 
            ctx.shadowColor = `rgba(255, 215, 0, ${hasShield ? 0.8 : 0.4})`; ctx.shadowBlur = 15;
            ctx.strokeStyle = `rgba(255, 215, 0, ${hasShield ? 0.9 : 0.4})`; ctx.lineWidth = hasShield ? 5 : 3;
            ctx.beginPath(); for(let k=0; k<8; k++) { ctx.moveTo(0,0); ctx.lineTo(60,0); ctx.rotate(Math.PI/4); } ctx.stroke();
            ctx.beginPath(); ctx.arc(0,0,55,0,Math.PI*2); ctx.stroke(); ctx.shadowBlur = 0;
            if (hasShield) {
                ctx.fillStyle = 'rgba(255, 64, 129, 0.4)';
                for(let k=0; k<6; k++) { ctx.rotate(Math.PI/3); ctx.beginPath(); ctx.ellipse(0, -60, 10, 30, 0, 0, Math.PI*2); ctx.fill(); }
            }
            if (muzzleFlash > 0) { ctx.fillStyle = `rgba(255, 255, 200, ${muzzleFlash/5})`; ctx.beginPath(); ctx.arc(0, -50, 40, 0, Math.PI*2); ctx.fill(); }
            ctx.rotate(-(player.haloAngle + player.tilt)); ctx.rotate(player.tilt);
            ctx.drawImage(playerImg, -32, -32, 64, 64);
            ctx.restore();

            ctx.globalCompositeOperation = 'lighter';
            bullets.forEach(b => {
                ctx.strokeStyle = 'rgba(255,255,0,0.5)'; ctx.lineWidth=10;
                ctx.beginPath(); ctx.moveTo(b.trail[0].x, b.trail[0].y); b.trail.forEach(t=>ctx.lineTo(t.x, t.y)); ctx.stroke();
                ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 10;
                ctx.drawImage(bulletImg, b.x-16, b.y-16, 32, 32); ctx.shadowBlur = 0;
            });
            ctx.globalCompositeOperation = 'source-over';

            enemies.forEach(e => {
                ctx.save(); ctx.translate(e.x + 35, e.y + 35); if (e.angle) ctx.rotate(e.angle); 
                if (e.type === 'interference_straight') {
                    ctx.fillStyle = '#ff1744'; ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*2); ctx.fill();
                } else {
                    ctx.drawImage(lotusImg, -35, -35, 70, 70);
                    if (e.idx === currentLevelCharIndex) {
                        ctx.strokeStyle = '#ffd700'; ctx.lineWidth=3; ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 20; 
                        let scale = 1 + Math.sin(timestamp*0.01)*0.1; ctx.scale(scale, scale);
                        ctx.beginPath(); ctx.arc(0, 0, 38, 0, Math.PI*2); ctx.stroke(); ctx.scale(1/scale, 1/scale); ctx.shadowBlur = 0;
                    }
                    ctx.font = "bold 30px 'Ma Shan Zheng'"; ctx.textAlign="center"; ctx.textBaseline="middle";
                    ctx.fillStyle = (e.idx === currentLevelCharIndex) ? '#ffd700' : '#fff';
                    ctx.shadowColor = 'black'; ctx.shadowBlur = 4; ctx.fillText(e.char, 0, 3);
                }
                ctx.restore();
            });

            if (gameState === 'BOSS' && boss.active) {
                ctx.save(); ctx.translate(boss.x, boss.y);
                let bossScale = 1 + Math.sin(timestamp * 0.003) * 0.05; ctx.scale(bossScale, bossScale);
                
                // 光輪
                ctx.save(); ctx.rotate(timestamp * 0.001);
                const ringGrad = ctx.createRadialGradient(0, 0, 60, 0, 0, 120);
                ringGrad.addColorStop(0, 'rgba(100, 0, 0, 0)'); ringGrad.addColorStop(0.5, 'rgba(255, 0, 0, 0.2)'); ringGrad.addColorStop(1, 'rgba(100, 0, 0, 0)');
                ctx.fillStyle = ringGrad; ctx.beginPath(); for(let i=0; i<12; i++) {
                    const angle = (i / 12) * Math.PI * 2; ctx.lineTo(Math.cos(angle)*120, Math.sin(angle)*120); ctx.lineTo(Math.cos(angle + 0.2)*80, Math.sin(angle + 0.2)*80);
                } ctx.closePath(); ctx.fill(); ctx.restore();

                // 本體
                const bodyGrad = ctx.createRadialGradient(-20, -20, 10, 0, 0, 90);
                bodyGrad.addColorStop(0, '#ff5252'); bodyGrad.addColorStop(0.3, '#b71c1c'); bodyGrad.addColorStop(1, '#000000');
                ctx.shadowColor = '#ff1744'; ctx.shadowBlur = 50; ctx.fillStyle = bodyGrad; ctx.beginPath(); ctx.arc(0, 0, 80, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
                
                ctx.strokeStyle = '#ff8a80'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-50, -20); ctx.quadraticCurveTo(-20, 10, 0, 50); ctx.moveTo(50, -20); ctx.quadraticCurveTo(20, 10, 0, 50); ctx.stroke();
                ctx.fillStyle = '#fff'; ctx.shadowColor = '#fff'; ctx.shadowBlur = 20;
                ctx.beginPath(); ctx.ellipse(-35, -15, 12, 25, 0.2, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(35, -15, 12, 25, -0.2, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#000'; ctx.shadowBlur = 0; ctx.beginPath(); ctx.arc(-35, -15, 4, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(35, -15, 4, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#ff1744'; ctx.beginPath(); ctx.moveTo(0, -60); ctx.lineTo(-10, -40); ctx.lineTo(0, -30); ctx.lineTo(10, -40); ctx.fill();
                ctx.restore();

                boss.weakPoints.forEach(wp => {
                    if (wp.active) {
                        ctx.save(); ctx.translate(wp.x, wp.y);
                        ctx.shadowColor = '#ff4081'; ctx.shadowBlur = 15;
                        const wpGrad = ctx.createRadialGradient(-5, -5, 2, 0, 0, 30);
                        wpGrad.addColorStop(0, '#fff'); wpGrad.addColorStop(0.3, '#ff80ab'); wpGrad.addColorStop(1, '#880e4f');
                        ctx.fillStyle = wpGrad; ctx.beginPath(); ctx.arc(0, 0, 32, 0, Math.PI*2); ctx.fill();
                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, 32, 0, Math.PI*2); ctx.stroke();
                        ctx.shadowBlur = 0; ctx.fillStyle = '#fff'; ctx.font = "bold 32px 'Ma Shan Zheng'"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(wp.text, 0, 2);
                        ctx.restore();
                    }
                });
            }

            for (let i = floatTexts.length - 1; i >= 0; i--) {
                let ft = floatTexts[i]; ft.life -= 0.04; if (ft.life <= 0) { floatTexts.splice(i, 1); continue; }
                ctx.save(); ctx.translate(ft.x + 35, ft.y + 35);
                let s = 1 + (1-ft.life) * 0.5; ctx.scale(s, s); ctx.globalAlpha = ft.life;
                ctx.fillStyle = '#ffd700'; ctx.shadowColor = '#ff6f00'; ctx.shadowBlur = 20;
                ctx.font = "bold 60px 'Ma Shan Zheng'"; ctx.fillText(ft.text, 0, 0); ctx.restore();
            }
        }

        particles.forEach((p, i) => {
            p.life -= 0.03; p.x += p.vx; p.y += p.vy;
            ctx.globalAlpha = p.life;
            if (p.type === 'trail') {
                ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2); ctx.fill();
            } else if (p.type === 'shockwave') {
                ctx.strokeStyle = p.color; ctx.lineWidth = 5 * p.life; p.size += 5; 
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.stroke();
            } else {
                ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
            }
            if (p.life<=0) particles.splice(i,1);
        });
        ctx.globalAlpha = 1.0;
        ctx.restore(); 

        requestAnimationFrame(gameLoop);
    }

    function createExplosion(x, y, color, big=false) {
        const count = big ? 30 : 10;
        for(let i=0; i<count; i++) {
            particles.push({
                x:x, y:y, vx:(Math.random()-0.5)*15, vy:(Math.random()-0.5)*15,
                life:1, color:color, size:Math.random()*6+2, type: 'spark'
            });
        }
        if (big) { particles.push({ x:x, y:y, vx:0, vy:0, life:1, color:color, size:10, type:'shockwave' }); }
    }

    function winGame() {
        gameState = 'GAMEOVER';
        bgmPlayer.pause(); 
        document.getElementById('end-title').innerText = "功德圓滿";
        document.getElementById('end-reason').innerText = "心無罣礙，究竟涅槃";
        document.getElementById('final-score').innerText = score;
        gameOverScreen.style.display = 'flex';
    }

    function gameOver(reason) {
        gameState = 'GAMEOVER';
        bgmPlayer.pause(); 
        document.getElementById('end-title').innerText = "修行未果";
        document.getElementById('end-reason').innerText = reason;
        document.getElementById('final-score').innerText = score;
        gameOverScreen.style.display = 'flex';
    }

    resize();
    requestAnimationFrame(gameLoop);

</script>
</body>
</html>