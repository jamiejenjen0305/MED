<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÂøÉÁ∂ìÊòüÈöõÂ§ßÂÜíÈö™</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Serif+TC:wght@500;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Noto Serif TC', serif;
            user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            height: 100%;
            background: #000;
            cursor: none;
            overflow: hidden;
            box-shadow: 0 0 60px rgba(0, 0, 0, 0.9), 0 0 20px rgba(100, 50, 255, 0.1);
        }

        #game-container::after {
            content: "";
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            z-index: 8;
        }

        #damage-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.6) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 9;
            transition: opacity 0.2s;
        }
        
        #fever-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(255, 215, 0, 0.3) 100%);
            opacity: 0;
            pointer-events: none;
            z-index: 8;
            transition: opacity 0.5s;
            mix-blend-mode: screen;
        }

        canvas {
            display: block;
            filter: contrast(1.1) saturate(1.2) brightness(1.1);
        }

        #dashboard {
            position: absolute;
            top: 15px; left: 10px; right: 10px;
            height: 80px;
            background: rgba(10, 10, 10, 0.6);
            backdrop-filter: blur(8px);
            border-radius: 12px;
            border: 1px solid rgba(255, 215, 0, 0.15);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 0 5px;
            z-index: 10;
            pointer-events: none;
        }

        #progress-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px 12px 0 0;
            overflow: hidden;
        }
        #progress-bar {
            width: 0%; height: 100%;
            background: #ffd700;
            box-shadow: 0 0 10px #ffd700;
            transition: width 0.3s;
        }

        #karma-container {
            position: absolute;
            bottom: 0; left: 0; width: 100%; height: 3px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0 0 12px 12px;
            overflow: hidden;
        }
        #karma-bar {
            width: 0%; height: 100%;
            background: #ff5252;
            transition: width 0.3s;
            box-shadow: 0 0 5px #ff1744;
        }

        .hud-group {
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }

        .hud-label {
            font-family: 'Noto Serif TC', serif;
            font-size: 10px; color: #aaa; letter-spacing: 1px;
            margin-bottom: 2px; 
        }

        .hud-value {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 22px; 
            color: #fff;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
        }

        #hp-display {
            font-size: 16px;
            letter-spacing: 2px;
            color: #ff5252;
        }

        #score { color: #fff8e1; }
        #combo { color: #ffd700; font-size: 24px; text-shadow: 0 0 8px rgba(255, 215, 0, 0.4); }
        
        #target-group {
            text-align: center;
            border-left: 1px solid rgba(255,255,255,0.1);
            padding-left: 12px;
            min-width: 50px;
        }

        #next-target {
            color: #ffd700; font-size: 38px;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.6);
            animation: pulse-target 2s infinite alternate;
            font-family: 'Ma Shan Zheng', cursive;
        }

        @keyframes pulse-target { from { transform: scale(1); opacity: 0.9; } to { transform: scale(1.05); opacity: 1; } }

        #level-display {
            font-family: 'Ma Shan Zheng', cursive; font-size: 18px;
            color: #eee;
            text-shadow: 0 0 3px #000;
            background: rgba(0,0,0,0.4); 
            padding: 4px 12px; border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #level-display-container {
            position: absolute; top: 105px; left: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 9;
        }

        #sound-btn {
            width: 32px;
            height: 32px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        #sound-btn svg {
            width: 18px;
            height: 18px;
            fill: #ccc; 
        }
        #sound-btn.muted svg {
            fill: #ef5350;
        }

        #start-screen, #game-over-screen, #level-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, rgba(10,10,15,0.95) 0%, #000 100%);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 30;
            cursor: default;
            backdrop-filter: blur(8px); padding: 20px; box-sizing: border-box;
        }

        #start-screen::before {
            content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 120vw; height: 120vw;
            background: repeating-conic-gradient(from 0deg, rgba(255,215,0,0.03) 0deg, transparent 10deg, rgba(255,215,0,0.03) 20deg);
            border-radius: 50%; animation: rotateBg 60s linear infinite; z-index: -1; pointer-events: none;
        }

        @keyframes rotateBg { from { transform: translate(-50%, -50%) rotate(0deg); } to { transform: translate(-50%, -50%) rotate(360deg); } }

        #level-screen { background: rgba(0, 0, 0, 0.85); display: none; z-index: 15; animation: fadeIn 0.5s; }

        h1 {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: clamp(30px, 8vw, 60px);
            background: linear-gradient(180deg, #fff 20%, #ffd700 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            margin: 0 0 30px 0;
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.4));
            animation: floatTitle 4s infinite ease-in-out;
            text-align: center; line-height: 1.2; width: 100%;
            padding: 0 10px;
        }
        
        #start-screen h1 {
            background: linear-gradient(180deg, #e3f2fd 0%, #2196f3 50%, #0d47a1 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            -webkit-text-stroke: 0.1px #fff;
            filter: drop-shadow(0 0 20px rgba(33, 150, 243, 0.5));
        }

        @keyframes floatTitle { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }

        .btn {
            margin-top: 40px; padding: 14px 50px; font-size: 24px;
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.2), rgba(255, 143, 0, 0.3));
            background-color: rgba(0,0,0,0.3);
            color: #fff8e1; border: 1px solid rgba(255, 215, 0, 0.6);
            border-radius: 50px; cursor: pointer;
            font-family: 'Ma Shan Zheng', cursive; transition: all 0.2s ease-out;
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.1);
            white-space: nowrap; letter-spacing: 3px;
            position: relative; overflow: hidden;
            pointer-events: auto;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            backdrop-filter: blur(4px);
        }
        .btn:hover { 
            transform: translateY(-2px); 
            background: linear-gradient(180deg, rgba(255, 215, 0, 0.4), rgba(255, 143, 0, 0.5));
            box-shadow: 0 0 25px rgba(255, 193, 7, 0.4);
            border-color: #ffd700;
            color: #fff;
        }
        .btn:active { transform: translateY(1px); }

        #collected-sutra {
            position: absolute; bottom: 0; left: 0; width: 100%; height: auto; min-height: 110px; max-height: 180px;
            background: linear-gradient(to top, #000 0%, rgba(0, 0, 0, 0.8) 60%, transparent 100%);
            border-top: 1px solid rgba(255, 255, 255, 0.05);
            display: flex; flex-wrap: wrap; justify-content: center; align-items: flex-end;
            padding: 10px 20px 35px 20px; pointer-events: none; z-index: 5; box-sizing: border-box; overflow: hidden;
        }

        .sutra-char {
            font-family: 'Ma Shan Zheng', cursive; font-size: 32px; color: #ffd700;
            margin: 0 4px; opacity: 0; display: inline-block;
            transform: translateY(20px); 
            animation: floatUpChar 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            text-shadow: 0 0 8px rgba(255, 160, 0, 0.6);
        }
        @keyframes floatUpChar { to { opacity: 1; transform: translateY(0); } }

        .instruction {
            margin-top: 10px; color: #ccc; font-size: 15px; line-height: 1.8; text-align: center;
            background: rgba(30, 30, 30, 0.6); padding: 18px 28px; border-radius: 16px; 
            width: 85%; max-width: 360px; border: 1px solid rgba(255,255,255,0.1);
        }
        .instruction p { margin: 6px 0; }
        .instruction strong { color: #ffd700; font-weight: normal; }

        #boss-hud {
            position: absolute; top: 120px; left: 50%; transform: translateX(-50%); 
            width: 40%; max-width: 200px; 
            display: none; flex-direction: column; align-items: center;
            background: transparent;
            z-index: 15;
        }
        #boss-name { 
            font-family: 'Ma Shan Zheng', cursive; color: #ff5252; 
            font-size: 20px; text-shadow: 0 0 5px #000; 
            margin-bottom: 5px; letter-spacing: 2px;
        }
        #boss-hp-bar { 
            width: 100%; height: 6px; 
            background: rgba(50, 0, 0, 0.6); 
            border: 1px solid rgba(255, 82, 82, 0.5); 
            border-radius: 4px; overflow: hidden; 
        }
        #boss-hp-fill { 
            width: 100%; height: 100%; 
            background: linear-gradient(90deg, #ff5252, #ff1744); 
            transition: width 0.2s; 
        }

        #level-title { font-family: 'Ma Shan Zheng', cursive; font-size: 60px; color: #ffd700; margin-bottom: 15px; text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); text-align: center; }
        #level-subtitle { font-family: 'Noto Serif TC', serif; font-size: 24px; color: #eee; letter-spacing: 4px; text-align: center; opacity: 0.9; }
        
        .floating-msg {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-family: 'Ma Shan Zheng', cursive; font-size: 60px; color: #ff4081;
            text-shadow: 0 0 30px rgba(255, 64, 129, 0.9), 0 0 10px #fff; opacity: 0; pointer-events: none;
            animation: floatUp 1.5s cubic-bezier(0.2, 0.8, 0.2, 1); z-index: 100; white-space: nowrap;
        }
        @keyframes floatUp { 
            0% { opacity: 0; transform: translate(-50%, -20%) scale(0.5); } 
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); } 
            100% { opacity: 0; transform: translate(-50%, -100%) scale(1); } 
        }
        
        #end-title {
            font-family: 'Ma Shan Zheng', cursive; font-size: 64px;
            background: linear-gradient(to bottom, #ffcdd2, #d32f2f);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            margin-bottom: 20px; filter: drop-shadow(0 0 10px rgba(211, 47, 47, 0.8));
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="damage-overlay"></div>
    <div id="fever-overlay"></div>

    <div id="dashboard">
        <div id="progress-container"><div id="progress-bar"></div></div>
        <div id="karma-container"><div id="karma-bar"></div></div>
        
        <div class="hud-group">
            <span class="hud-label">ÁîüÂëΩ</span>
            <div id="hp-display">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        </div>

        <div class="hud-group">
            <span class="hud-label">ÂäüÂæ∑</span>
            <span class="hud-value" id="score">0</span>
        </div>

        <div class="hud-group">
            <span class="hud-label">ÈÄ£Êìä</span>
            <span class="hud-value" id="combo">0</span>
        </div>

        <div class="hud-group" id="target-group">
            <span class="hud-label">‰∏ã‰∏ÄÂ≠ó</span>
            <span class="hud-value" id="next-target">-</span>
        </div>
    </div>
    
    <div id="level-display-container">
        <div id="level-display">Á¨¨ 1 Èóú</div>
        <div id="sound-btn">
            <svg viewBox="0 0 24 24" id="icon-sound-on">
                <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
            </svg>
            <svg viewBox="0 0 24 24" id="icon-sound-off" style="display:none;">
                <path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73 4.27 3zM12 4L9.91 6.09 12 8.18V4z"/>
            </svg>
        </div>
    </div>

    <div id="boss-hud">
        <div id="boss-name">‰∫îËòäÂøÉÈ≠î</div>
        <div id="boss-hp-bar"><div id="boss-hp-fill"></div></div>
    </div>

    <div id="collected-sutra"></div>

    <div id="start-screen">
        <h1>ÂøÉÁ∂ìÊòüÈöõÂ§ßÂÜíÈö™</h1>
        <div class="instruction">
            <p><strong>ÊªëÂãïÔºö</strong>Ê≥ïËº™Ëá™Áî±È£õË°å</p>
            <p><strong>Êåâ‰ΩèÔºö</strong>Ëá™ÂãïÁôºÂ∞Ñ‰ΩõÂÖâ</p>
            <p><strong>ÁîüÂ≠òÔºö</strong>ÊìÅÊúâ 3 È°ÜÂøÉÔºå5ÈÄ£ÊìäÊéâËêΩË£úË°Ä</p>
            <p><strong>BossÔºö</strong>ÊØè 3 ÈóúÈ≠îÁéãÈÄ≤ÂåñÔºåÈõ£Â∫¶ÊèêÂçá</p>
            <p><strong>ÈöúÁ§ôÔºö</strong>Â∞èÂøÉÈÅøÈñãÈöïÁü≥„ÄÅÂ§ñÊòü‰∫∫„ÄÅÈ£õÁ¢ü</p>
        </div>
        <button class="btn" id="start-btn">ÈñãÂßãÂÜíÈö™</button>
    </div>

    <div id="level-screen">
        <div id="level-title">Á¨¨ 1 Èóú ÂÆåÊàê</div>
        <div id="level-subtitle">ÂøÉÁÑ°ÁΩ£Á§ô ÁπºÁ∫åÂâçË°å</div>
    </div>

    <div id="game-over-screen" style="display: none;">
        <h1 id="end-title">‰øÆË°åÊú™Êûú</h1>
        <p id="end-reason" style="font-size: 24px; color: #ff8a80; margin-bottom: 20px;"></p>
        <p class="instruction">ÊúÄÁµÇÂäüÂæ∑: <span id="final-score">0</span></p>
        <button class="btn" id="restart-btn">ÈáçÊñ∞‰æÜÈÅé</button>
    </div>
</div>

<audio id="bgm-player" loop src="https://jamiejenjen0305.github.io/MED/meditation-background-434654.mp3"></audio>

<script>
    // Á´ãÂç≥Âü∑Ë°åÂáΩÂºè
    (function() {
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const comboEl = document.getElementById('combo');
        const targetEl = document.getElementById('next-target');
        const levelIndEl = document.getElementById('level-display'); 
        const collectedEl = document.getElementById('collected-sutra');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const levelScreen = document.getElementById('level-screen');
        const levelTitle = document.getElementById('level-title');
        const levelSubtitle = document.getElementById('level-subtitle');
        const bossHud = document.getElementById('boss-hud');
        const bossHpFill = document.getElementById('boss-hp-fill');
        const bgmPlayer = document.getElementById('bgm-player');
        const progressBar = document.getElementById('progress-bar');
        const hpDisplay = document.getElementById('hp-display');
        const damageOverlay = document.getElementById('damage-overlay');
        const startBtn = document.getElementById('start-btn');
        const restartBtn = document.getElementById('restart-btn');
        const karmaBar = document.getElementById('karma-bar');
        const feverOverlay = document.getElementById('fever-overlay');
        
        // Èü≥ÊïàÊéßÂà∂
        const soundBtn = document.getElementById('sound-btn');
        const iconSoundOn = document.getElementById('icon-sound-on');
        const iconSoundOff = document.getElementById('icon-sound-off');
        let isMuted = false;

        const textureCache = {};

        // ÂèÉÊï∏
        const STAR_COUNT = 300; 
        const STAR_SPEED = 2;
        const PLANET_COLORS = [
            ['#2196f3', '#000000'], ['#fbc02d', '#3e2723'], ['#d32f2f', '#212121'], 
            ['#ff9800', '#3e2723'], ['#8d6e63', '#1a1a1a'], ['#00bcd4', '#000000'], 
            ['#3f51b5', '#000000'], ['#607d8b', '#000000'], ['#f44336', '#3e2723']
        ];
        const BOSS_THEMES = [
            { main: '#ff5252', light: '#ff8a80', glow: '#d50000' }, 
            { main: '#e040fb', light: '#ea80fc', glow: '#aa00ff' }, 
            { main: '#00e676', light: '#69f0ae', glow: '#00c853' }, 
            { main: '#2979ff', light: '#82b1ff', glow: '#2962ff' }  
        ];

        // --- Utility Functions ---
        
        function toggleMute() {
            isMuted = !isMuted;
            if (isMuted) {
                iconSoundOn.style.display = 'none';
                iconSoundOff.style.display = 'block';
                soundBtn.classList.add('muted');
                if(bgmPlayer) bgmPlayer.pause();
                if ('speechSynthesis' in window) window.speechSynthesis.cancel();
            } else {
                iconSoundOn.style.display = 'block';
                iconSoundOff.style.display = 'none';
                soundBtn.classList.remove('muted');
                if(bgmPlayer && gameState === 'PLAYING') bgmPlayer.play().catch(e => console.log(e));
            }
        }
        
        soundBtn.addEventListener('click', toggleMute);

        function showFloatingMsg(text, type = 'normal', x, y) {
            const div = document.createElement('div');
            div.className = 'floating-msg'; div.innerText = text;
            const container = document.getElementById('game-container');
            if (x && y) { 
                x = Math.max(0, Math.min(x, container.clientWidth));
                div.style.left = x + 'px'; div.style.top = y + 'px'; 
            }
            if (type === 'golden') { div.style.color = '#ffd700'; div.style.textShadow = '0 0 30px #ffd700'; }
            if (type === 'crit') { div.style.color = '#ff1744'; div.style.fontSize = '40px'; div.innerText = text + "!"; }
            if (type === 'heal') { div.style.color = '#00e676'; div.style.fontSize = '30px'; div.innerText = "+" + text; }
            container.appendChild(div);
            setTimeout(() => div.remove(), 1500);
        }

        function createExplosion(x, y, color, big=false) {
            const count = big ? 30 : 10;
            for(let i=0; i<count; i++) {
                particles.push({
                    x:x, y:y, vx:(Math.random()-0.5)*15, vy:(Math.random()-0.5)*15,
                    life:1, color:color, size:Math.random()*6+2, type: 'spark'
                });
            }
            if (big) { particles.push({ x:x, y:y, vx:0, vy:0, life:1, color:color, size:10, type:'shockwave' }); }
        }

        function gameOver(reason) {
            gameState = 'GAMEOVER';
            bgmPlayer.pause(); 
            document.getElementById('end-title').innerText = "‰øÆË°åÊú™Êûú";
            document.getElementById('end-reason').innerText = reason;
            document.getElementById('final-score').innerText = score;
            gameOverScreen.style.display = 'flex';
        }

        function winGame() {
            gameState = 'GAMEOVER';
            bgmPlayer.pause(); 
            document.getElementById('end-title').innerText = "ÂäüÂæ∑ÂúìÊªø";
            document.getElementById('end-reason').innerText = "ÂøÉÁÑ°ÁΩ£Á§ôÔºåÁ©∂Á´üÊ∂ÖÊßÉ";
            document.getElementById('final-score').innerText = score;
            gameOverScreen.style.display = 'flex';
        }

        function updateHP() {
            if (!hpDisplay) return;
            let hearts = "";
            for(let i=0; i<player.hp; i++) hearts += "‚ù§Ô∏è ";
            for(let i=player.hp; i<player.maxHp; i++) hearts += "üñ§ ";
            hpDisplay.innerHTML = hearts;
        }

        function updateKarma() {
            if(karmaBar) karmaBar.style.width = Math.min(100, player.karma) + '%';
        }

        let lastSpeakTime = 0;
        function speakText(text) {
            if (isMuted) return; 
            if (Date.now() - lastSpeakTime < 200) return;
            lastSpeakTime = Date.now();
            try {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel(); 
                    let spokenText = text.replace(/Ëà¨/g, 'Ê≥¢').replace(/Ëã•/g, 'ÊÉπ').replace(/Â≠ê/g, 'Á¥´').replace(/Âàá/g, 'ÊÄØ');
                    const utterance = new SpeechSynthesisUtterance(spokenText);
                    utterance.lang = 'zh-TW'; utterance.rate = 1.5; utterance.volume = 1.0;
                    window.speechSynthesis.speak(utterance);
                }
            } catch(e) { console.warn("Speech error ignored"); }
        }

        function readLevelContent(text, callback) {
            if (isMuted) {
                levelTransitionTimeout = setTimeout(callback, 2000);
                return;
            }
            try {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel();
                    
                    let spokenText = text.replace(/Ëà¨/g, 'Ê≥¢').replace(/Ëã•/g, 'ÊÉπ').replace(/Â≠ê/g, 'Á¥´').replace(/Âàá/g, 'ÊÄØ');

                    const utterance = new SpeechSynthesisUtterance(spokenText);
                    utterance.lang = 'zh-TW';
                    utterance.rate = 1.0; 
                    utterance.volume = 1.0;

                    let isCalled = false;
                    const done = () => {
                        if (!isCalled) {
                            isCalled = true;
                            if (callback) callback();
                        }
                    };

                    utterance.onend = done;
                    utterance.onerror = done;
                    
                    levelTransitionTimeout = setTimeout(done, text.length * 400 + 2000);

                    window.speechSynthesis.speak(utterance);
                } else {
                    levelTransitionTimeout = setTimeout(callback, 2000);
                }
            } catch (e) {
                console.warn("Level read error", e);
                if (callback) callback();
            }
        }

        function createTexture(type, subType) {
            if (textureCache[type + (subType || '')]) return textureCache[type + (subType || '')];

            const tmpCanvas = document.createElement('canvas');
            const tmpCtx = tmpCanvas.getContext('2d');
            tmpCanvas.width = 128; tmpCanvas.height = 128;

            if (type === 'player') {
                const grad = tmpCtx.createRadialGradient(64, 64, 10, 64, 64, 60);
                grad.addColorStop(0, '#fffde7'); grad.addColorStop(0.3, '#ffca28'); grad.addColorStop(0.8, '#ff6f00'); grad.addColorStop(1, '#bf360c');
                tmpCtx.shadowColor = 'rgba(255, 193, 7, 0.8)'; tmpCtx.shadowBlur = 25; 
                tmpCtx.fillStyle = grad;
                
                tmpCtx.beginPath();
                for(let i=0; i<8; i++) {
                    const angle = (i/8) * Math.PI * 2;
                    tmpCtx.moveTo(64, 64);
                    tmpCtx.lineTo(64 + Math.cos(angle)*60, 64 + Math.sin(angle)*60);
                }
                tmpCtx.lineWidth = 8; tmpCtx.strokeStyle = '#fff8e1'; tmpCtx.stroke();
                
                tmpCtx.beginPath(); tmpCtx.arc(64, 64, 54, 0, Math.PI * 2);
                tmpCtx.lineWidth = 6; tmpCtx.strokeStyle = '#ffd54f'; tmpCtx.stroke();
                
                tmpCtx.beginPath(); tmpCtx.arc(64, 64, 20, 0, Math.PI * 2);
                tmpCtx.fillStyle = '#fff'; tmpCtx.fill();
                
                tmpCtx.fillStyle = '#ff6f00'; tmpCtx.font = "bold 30px 'Ma Shan Zheng'"; 
                tmpCtx.textAlign = "center"; tmpCtx.textBaseline = "middle"; 
                tmpCtx.shadowBlur = 0; 
                tmpCtx.fillText("Âçç", 64, 66);

            } else if (type === 'lotus') {
                const colors = ['#f48fb1', '#ec407a', '#c2185b']; tmpCtx.shadowColor = '#f50057'; tmpCtx.shadowBlur = 25;
                for(let layer=0; layer<3; layer++) {
                    const petalGrad = tmpCtx.createRadialGradient(64, 64, 10, 64, 64, 60);
                    petalGrad.addColorStop(0, '#fce4ec'); petalGrad.addColorStop(0.5, colors[layer]); petalGrad.addColorStop(1, '#880e4f');
                    tmpCtx.fillStyle = petalGrad; tmpCtx.strokeStyle = 'rgba(255,255,255,0.8)'; tmpCtx.lineWidth = 1.5;
                    const petals = 10 - layer * 2; const radius = 54 - layer * 12; 
                    for(let i=0; i<petals; i++) {
                        const angle = (i / petals) * Math.PI * 2 + (layer * 0.5); 
                        const cx = 64 + Math.cos(angle) * radius * 0.55; const cy = 64 + Math.sin(angle) * radius * 0.55;
                        tmpCtx.beginPath(); tmpCtx.ellipse(cx, cy, 14 - layer*2, radius*0.6, angle, 0, Math.PI*2); tmpCtx.fill(); tmpCtx.stroke();
                    }
                }
                const centerGrad = tmpCtx.createRadialGradient(64, 64, 2, 64, 64, 25);
                centerGrad.addColorStop(0, '#ffc107'); centerGrad.addColorStop(0.4, '#ad1457'); centerGrad.addColorStop(1, '#4a0072'); 
                tmpCtx.fillStyle = centerGrad; tmpCtx.beginPath(); tmpCtx.arc(64, 64, 22, 0, Math.PI*2); tmpCtx.fill();
                tmpCtx.strokeStyle = '#ffb74d'; tmpCtx.lineWidth = 2; tmpCtx.stroke();
            } else if (type === 'bullet') {
                tmpCtx.font = "bold 80px 'Ma Shan Zheng'"; tmpCtx.textAlign = "center"; tmpCtx.textBaseline = "middle";
                tmpCtx.shadowColor = '#ff3d00'; tmpCtx.shadowBlur = 30; tmpCtx.fillStyle = '#ffeb3b'; tmpCtx.fillText("Âçç", 64, 68);
                tmpCtx.shadowColor = '#fff'; tmpCtx.shadowBlur = 10; tmpCtx.fillStyle = '#ffffff'; tmpCtx.fillText("Âçç", 64, 68);
            } else if (type === 'powerup_spread') {
                tmpCtx.shadowColor = '#ffd700'; tmpCtx.shadowBlur = 20; tmpCtx.fillStyle = '#fbc02d';
                for(let i=0; i<8; i++) {
                    let angle = i * Math.PI / 4; tmpCtx.beginPath(); tmpCtx.ellipse(64 + Math.cos(angle)*30, 64 + Math.sin(angle)*30, 10, 20, angle, 0, Math.PI*2); tmpCtx.fill();
                }
                tmpCtx.beginPath(); tmpCtx.arc(64,64,20,0,Math.PI*2); tmpCtx.fillStyle='#fff9c4'; tmpCtx.fill();
            } else if (type === 'powerup_freeze') {
                const grad = tmpCtx.createRadialGradient(64, 64, 10, 64, 64, 50);
                grad.addColorStop(0, '#b9f6ca'); grad.addColorStop(1, '#00bfa5'); 
                tmpCtx.fillStyle = grad; tmpCtx.shadowColor = '#1de9b6'; tmpCtx.shadowBlur = 25;
                tmpCtx.beginPath(); tmpCtx.arc(64,64,50,0,Math.PI*2); tmpCtx.fill();
                tmpCtx.fillStyle = '#004d40'; tmpCtx.shadowBlur = 0; tmpCtx.font = "bold 60px 'Ma Shan Zheng'";
                tmpCtx.textAlign="center"; tmpCtx.textBaseline="middle"; tmpCtx.fillText("ÂÆö", 64, 68);
            } else if (type === 'powerup_heal') {
                const grad = tmpCtx.createRadialGradient(64, 64, 10, 64, 64, 50);
                grad.addColorStop(0, '#ff8a80'); grad.addColorStop(1, '#d50000');
                tmpCtx.fillStyle = grad; tmpCtx.shadowColor = '#ff1744'; tmpCtx.shadowBlur = 25;
                tmpCtx.beginPath();
                tmpCtx.moveTo(64, 90);
                tmpCtx.bezierCurveTo(64, 85, 30, 65, 30, 45); tmpCtx.bezierCurveTo(30, 25, 60, 25, 64, 45);
                tmpCtx.bezierCurveTo(68, 25, 98, 25, 98, 45); tmpCtx.bezierCurveTo(98, 65, 64, 85, 64, 90);
                tmpCtx.fill();
            } else if (type === 'boss_bullet') {
                const char = subType || 'Ê•≠';
                const grad = tmpCtx.createRadialGradient(64, 64, 20, 64, 64, 60);
                grad.addColorStop(0, '#ffeb3b'); grad.addColorStop(0.5, '#ff5722'); grad.addColorStop(1, '#bf360c');
                tmpCtx.fillStyle = grad;
                tmpCtx.shadowColor = '#ff3d00'; tmpCtx.shadowBlur = 30;
                tmpCtx.beginPath(); tmpCtx.arc(64, 64, 40, 0, Math.PI*2); tmpCtx.fill();
                
                for(let i=0; i<8; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 40 + Math.random() * 15;
                    tmpCtx.beginPath(); tmpCtx.arc(64+Math.cos(angle)*dist, 64+Math.sin(angle)*dist, 5, 0, Math.PI*2); tmpCtx.fill();
                }

                tmpCtx.fillStyle = '#fff';
                tmpCtx.font = "bold 50px 'Ma Shan Zheng'";
                tmpCtx.textAlign = "center"; tmpCtx.textBaseline = "middle";
                tmpCtx.shadowBlur = 10;
                tmpCtx.fillText(char, 64, 68);
            } 
            // ÈöúÁ§ôÁâ©Ë≤ºÂúñ
            else if (type === 'obstacle_meteor') { 
                const grad = tmpCtx.createRadialGradient(50, 50, 5, 64, 64, 60);
                grad.addColorStop(0, '#8d6e63'); grad.addColorStop(1, '#3e2723');
                tmpCtx.fillStyle = grad;
                tmpCtx.beginPath();
                tmpCtx.moveTo(64, 20); tmpCtx.lineTo(90, 40); tmpCtx.lineTo(100, 80);
                tmpCtx.lineTo(70, 110); tmpCtx.lineTo(40, 100); tmpCtx.lineTo(20, 60);
                tmpCtx.lineTo(35, 30); tmpCtx.closePath(); tmpCtx.fill();
                tmpCtx.fillStyle = 'rgba(0,0,0,0.3)';
                tmpCtx.beginPath(); tmpCtx.arc(50, 50, 10, 0, Math.PI*2); tmpCtx.fill();
                tmpCtx.beginPath(); tmpCtx.arc(80, 70, 8, 0, Math.PI*2); tmpCtx.fill();
                tmpCtx.beginPath(); tmpCtx.arc(50, 90, 6, 0, Math.PI*2); tmpCtx.fill();

            } else if (type === 'obstacle_ufo') {
                tmpCtx.fillStyle = '#e1f5fe';
                tmpCtx.beginPath(); tmpCtx.arc(64, 50, 20, Math.PI, 0); tmpCtx.fill();
                const ufoGrad = tmpCtx.createLinearGradient(0, 50, 0, 80);
                ufoGrad.addColorStop(0, '#b0bec5'); ufoGrad.addColorStop(1, '#607d8b');
                tmpCtx.fillStyle = ufoGrad;
                tmpCtx.beginPath(); tmpCtx.ellipse(64, 60, 50, 15, 0, 0, Math.PI*2); tmpCtx.fill();
                for(let i=0; i<5; i++) {
                    tmpCtx.fillStyle = (i%2===0) ? '#ffeb3b' : '#ff1744';
                    tmpCtx.beginPath(); tmpCtx.arc(34 + i*15, 60, 3, 0, Math.PI*2); tmpCtx.fill();
                }
            } else if (type === 'obstacle_alien') {
                tmpCtx.fillStyle = '#69f0ae';
                tmpCtx.beginPath();
                tmpCtx.moveTo(64, 20); tmpCtx.quadraticCurveTo(100, 20, 100, 60);
                tmpCtx.quadraticCurveTo(100, 110, 64, 110); tmpCtx.quadraticCurveTo(28, 110, 28, 60);
                tmpCtx.quadraticCurveTo(28, 20, 64, 20); tmpCtx.fill();
                tmpCtx.fillStyle = '#000';
                tmpCtx.beginPath(); tmpCtx.ellipse(45, 60, 12, 20, 0.2, 0, Math.PI*2); tmpCtx.fill();
                tmpCtx.beginPath(); tmpCtx.ellipse(83, 60, 12, 20, -0.2, 0, Math.PI*2); tmpCtx.fill();
            } else if (type === 'obstacle_flower') {
                 tmpCtx.fillStyle = '#f48fb1';
                 for(let i=0; i<5; i++) {
                     const angle = (i/5)*Math.PI*2;
                     tmpCtx.beginPath();
                     tmpCtx.ellipse(64 + Math.cos(angle)*20, 64 + Math.sin(angle)*20, 15, 25, angle, 0, Math.PI*2);
                     tmpCtx.fill();
                 }
                 tmpCtx.fillStyle = '#fff59d';
                 tmpCtx.beginPath(); tmpCtx.arc(64, 64, 10, 0, Math.PI*2); tmpCtx.fill();
            } else if (type === 'obstacle_fruit') {
                const grad = tmpCtx.createRadialGradient(50, 50, 5, 64, 64, 50);
                grad.addColorStop(0, '#ffcdd2'); grad.addColorStop(1, '#e91e63');
                tmpCtx.fillStyle = grad;
                tmpCtx.beginPath(); tmpCtx.arc(64, 64, 40, 0, Math.PI*2); tmpCtx.fill();
                tmpCtx.fillStyle = '#4caf50';
                tmpCtx.beginPath(); tmpCtx.ellipse(64, 24, 8, 16, -0.5, 0, Math.PI*2); tmpCtx.fill();
            } else if (type === 'obstacle_apple') {
                const grad = tmpCtx.createRadialGradient(50, 50, 5, 64, 64, 50);
                grad.addColorStop(0, '#ffcdd2'); grad.addColorStop(1, '#d32f2f');
                tmpCtx.fillStyle = grad;
                tmpCtx.beginPath(); tmpCtx.arc(64, 64, 42, 0, Math.PI*2); tmpCtx.fill();
                tmpCtx.fillStyle = '#4caf50';
                tmpCtx.beginPath(); tmpCtx.ellipse(64, 20, 8, 16, 0.5, 0, Math.PI*2); tmpCtx.fill();
            } else if (type === 'obstacle_pear') {
                const grad = tmpCtx.createLinearGradient(64, 20, 64, 100);
                grad.addColorStop(0, '#fff9c4'); grad.addColorStop(1, '#fbc02d');
                tmpCtx.fillStyle = grad;
                tmpCtx.beginPath();
                tmpCtx.ellipse(64, 70, 40, 45, 0, 0, Math.PI*2);
                tmpCtx.ellipse(64, 40, 25, 30, 0, 0, Math.PI*2);
                tmpCtx.fill();
            }

            const url = tmpCanvas.toDataURL('image/png');
            textureCache[type + (subType || '')] = url;
            return url;
        }

        const playerImg = new Image(); playerImg.src = createTexture('player');
        const lotusImg = new Image(); lotusImg.src = createTexture('lotus'); 
        const bulletImg = new Image(); bulletImg.src = createTexture('bullet');
        const spreadImg = new Image(); spreadImg.src = createTexture('powerup_spread');
        const freezeImg = new Image(); freezeImg.src = createTexture('powerup_freeze');
        const healImg = new Image(); healImg.src = createTexture('powerup_heal');
        const bossBulletImgs = {};
        ['Ê•≠','Èöú','Ëã¶','È≠î','Ë≤™','Âóî','Áô°'].forEach(c => {
            const img = new Image();
            img.src = createTexture('boss_bullet', c);
            bossBulletImgs[c] = img;
        });
        
        const obstacleImgs = {};
        const obstacleTypes = ['meteor', 'ufo', 'alien', 'flower', 'fruit', 'apple', 'pear'];
        obstacleTypes.forEach(t => {
            obstacleImgs[t] = new Image();
            obstacleImgs[t].src = createTexture('obstacle_' + t);
        });

        const LEVEL_TEXTS = [
            "ËßÄËá™Âú®Ëè©Ëñ©Ë°åÊ∑±Ëà¨Ëã•Ê≥¢ÁæÖËúúÂ§öÊôÇ", "ÁÖßË¶ã‰∫îËòäÁöÜÁ©∫Â∫¶‰∏ÄÂàáËã¶ÂéÑ", "ËàçÂà©Â≠êËâ≤‰∏çÁï∞Á©∫Á©∫‰∏çÁï∞Ëâ≤", "Ëâ≤Âç≥ÊòØÁ©∫Á©∫Âç≥ÊòØËâ≤", "ÂèóÊÉ≥Ë°åË≠ò‰∫¶Âæ©Â¶ÇÊòØ",
            "ËàçÂà©Â≠êÊòØË´∏Ê≥ïÁ©∫Áõ∏", "‰∏çÁîü‰∏çÊªÖ‰∏çÂû¢‰∏çÊ∑®‰∏çÂ¢û‰∏çÊ∏õ", "ÊòØÊïÖÁ©∫‰∏≠ÁÑ°Ëâ≤ÁÑ°ÂèóÊÉ≥Ë°åË≠ò", "ÁÑ°ÁúºËÄ≥ÈºªËàåË∫´ÊÑèÁÑ°Ëâ≤ËÅ≤È¶ôÂë≥Ëß∏Ê≥ï", "ÁÑ°ÁúºÁïå‰πÉËá≥ÁÑ°ÊÑèË≠òÁïå",
            "ÁÑ°ÁÑ°Êòé‰∫¶ÁÑ°ÁÑ°ÊòéÁõ°", "‰πÉËá≥ÁÑ°ËÄÅÊ≠ª‰∫¶ÁÑ°ËÄÅÊ≠ªÁõ°", "ÁÑ°Ëã¶ÈõÜÊªÖÈÅìÁÑ°Êô∫‰∫¶ÁÑ°Âæó‰ª•ÁÑ°ÊâÄÂæóÊïÖ", "Ëè©ÊèêËñ©Âüµ‰æùËà¨Ëã•Ê≥¢ÁæÖËúúÂ§öÊïÖ", "ÂøÉÁÑ°ÁΩ£Á§ôÁÑ°ÁΩ£Á§ôÊïÖÁÑ°ÊúâÊÅêÊÄñ",
            "ÈÅ†Èõ¢È°õÂÄíÂ§¢ÊÉ≥Á©∂Á´üÊ∂ÖÊßÉ", "‰∏â‰∏ñË´∏‰Ωõ‰æùËà¨Ëã•Ê≥¢ÁæÖËúúÂ§öÊïÖ", "ÂæóÈòøËÄ®Â§öÁæÖ‰∏âËóê‰∏âËè©Êèê", "ÊïÖÁü•Ëà¨Ëã•Ê≥¢ÁæÖËúúÂ§ö", "ÊòØÂ§ßÁ•ûÂííÊòØÂ§ßÊòéÂíí",
            "ÊòØÁÑ°‰∏äÂííÊòØÁÑ°Á≠âÁ≠âÂíí", "ËÉΩÈô§‰∏ÄÂàáËã¶ÁúüÂØ¶‰∏çËôõ", "ÊïÖË™™Ëà¨Ëã•Ê≥¢ÁæÖËúúÂ§öÂííÂç≥Ë™™ÂííÊõ∞", "Êè≠Ë´¶Êè≠Ë´¶Ê≥¢ÁæÖÊè≠Ë´¶", "Ê≥¢ÁæÖÂÉßÊè≠Ë´¶Ëè©ÊèêËñ©Â©ÜË®∂"
        ];

        let gameState = 'START'; 
        let score = 0;
        let comboCount = 0;
        let currentLevelIndex = 0;
        let currentLevelCharIndex = 0;
        
        const player = { x: 0, y: 0, width: 64, height: 64, targetX: 0, targetY: 0, haloAngle: 0, tilt: 0, hp: 3, maxHp: 3, karma: 0 };
        let hasShield = false;
        let spreadTimer = 0; 
        let freezeTimer = 0; 
        let shakeIntensity = 0;
        let muzzleFlash = 0; 
        let isFiring = false; 

        let enemies = [];
        let bullets = [];
        let particles = [];
        let floatTexts = []; 
        let items = []; 
        
        let stars = [];
        let nebulas = [];
        let mandalas = []; 
        let spiritDust = []; 
        
        let boss = { active: false, x: 0, y: -200, hp: 100, maxHp: 100, weakPoints: [], attackTimer: 0, defeated: false, type: 0, angle: 0, isDying: false, opacity: 1, deathTimer: 0, theme: null };
        
        let levelTransitionTimeout = null;
        let lastAutoShoot = 0;

        let lastTime = 0;
        let spawnTimer = 0;
        let obstacleTimer = 0; 
        const spawnInterval = 1500;
        let waveQueue = [];
        let animationFrameId = null; 

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();
        const PENTATONIC_SCALE = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25, 783.99, 880.00, 1046.50];

        // Ëß£ÈéñÈü≥ÊïàÂºïÊìé (ÈáùÂ∞ç iOS/Mobile)
        function unlockAudio() {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().catch(e => console.log(e));
            }
            if ('speechSynthesis' in window) {
                const u = new SpeechSynthesisUtterance(" ");
                window.speechSynthesis.speak(u);
            }
        }

        function playSound(type, combo = 0) {
            if (isMuted) return; // ÈùúÈü≥Ê™¢Êü•

            if (audioCtx.state === 'suspended') audioCtx.resume().catch(() => {});
            try {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain); gain.connect(audioCtx.destination);
                const now = audioCtx.currentTime;

                if (type === 'hit') {
                    osc.type = 'sine';
                    let noteIndex = Math.min(combo, PENTATONIC_SCALE.length - 1);
                    let freq = PENTATONIC_SCALE[noteIndex];
                    osc.frequency.setValueAtTime(freq, now);
                    osc.frequency.exponentialRampToValueAtTime(freq, now + 0.1); 
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                    osc.start(); osc.stop(now + 0.3);
                } else if (type === 'shoot') {
                    osc.type = 'triangle'; 
                    osc.frequency.setValueAtTime(spreadTimer > 0 ? 800 : 600, now);
                    osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
                    gain.gain.setValueAtTime(0.05, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                    osc.start(); osc.stop(now + 0.15);
                } else if (type === 'damage') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.linearRampToValueAtTime(50, now + 0.4);
                    gain.gain.setValueAtTime(0.5, now);
                    gain.gain.linearRampToValueAtTime(0.01, now + 0.4);
                    osc.start(); osc.stop(now + 0.4);
                } else if (type === 'heal') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(400, now);
                    osc.frequency.linearRampToValueAtTime(800, now + 0.3);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.linearRampToValueAtTime(0.01, now + 0.5);
                    osc.start(); osc.stop(now + 0.5);
                } else if (type === 'powerup') {
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(523, now);
                    osc.frequency.linearRampToValueAtTime(1046, now + 0.3);
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.linearRampToValueAtTime(0.01, now + 0.5);
                    osc.start(); osc.stop(now + 0.5);
                } else if (type === 'boss_roar') {
                    osc.type = 'sawtooth';
                    osc.frequency.setValueAtTime(80, now);
                    osc.frequency.linearRampToValueAtTime(40, now + 1.0);
                    gain.gain.setValueAtTime(0.5, now);
                    gain.gain.linearRampToValueAtTime(0.01, now + 1.0);
                    osc.start(); osc.stop(now + 1.0);
                }
            } catch(e) {}
        }

        function triggerShake(intensity) { shakeIntensity = intensity; }

        function initUniverse() {
            stars = []; nebulas = []; mandalas = []; spiritDust = [];
            for (let i = 0; i < STAR_COUNT; i++) {
                stars.push({
                    x: (Math.random() - 0.5) * canvas.width * 3, y: (Math.random() - 0.5) * canvas.height * 3,
                    z: Math.random() * canvas.width, color: Math.random() > 0.7 ? '#e0f7fa' : '#fff', size: Math.random() * 2
                });
            }
            for (let i = 0; i < 5; i++) {
                nebulas.push({
                    x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: 150 + Math.random() * 250,
                    color: `hsla(${Math.random() * 60 + 240}, 80%, 60%, 0.12)`, vx: (Math.random() - 0.5) * 0.3, vy: (Math.random() - 0.5) * 0.3
                });
            }
            for (let i = 0; i < 3; i++) {
                mandalas.push({
                    x: canvas.width / 2, y: canvas.height / 2 + (Math.random()-0.5)*200, radius: 250 + i * 180,
                    points: 8 + i * 4, angle: Math.random() * Math.PI, speed: 0.001 * (i % 2 === 0 ? 1 : -1), opacity: 0.06 + i * 0.02
                });
            }
            for (let i = 0; i < 40; i++) { 
                spiritDust.push({
                    x: Math.random() * canvas.width, y: Math.random() * canvas.height, vy: -0.8 - Math.random(), 
                    size: Math.random() * 2.5 + 1, opacity: Math.random() * 0.6 + 0.3
                });
            }
        }

        function resize() {
            const container = document.getElementById('game-container');
            if (!container) return;
            canvas.width = container.clientWidth; canvas.height = container.clientHeight;
            player.y = canvas.height - 110; player.x = canvas.width / 2;
            player.targetX = player.x; player.targetY = player.y;
            initUniverse();
        }
        window.addEventListener('resize', resize);
        
        let canvasRect = canvas.getBoundingClientRect();
        window.addEventListener('scroll', () => { canvasRect = canvas.getBoundingClientRect(); });
        window.addEventListener('resize', () => { canvasRect = canvas.getBoundingClientRect(); });

        function handleMove(clientX, clientY) {
            if (gameState === 'PLAYING' || gameState === 'BOSS') {
                player.targetX = clientX - canvasRect.left;
                player.targetY = clientY - canvasRect.top;
            }
        }

        document.addEventListener('mousemove', (e) => handleMove(e.clientX, e.clientY));
        document.addEventListener('mousedown', (e) => {
            if (e.target.tagName !== 'BUTTON' && e.target.id !== 'sound-btn' && !e.target.closest('#sound-btn')) isFiring = true; 
        });
        document.addEventListener('mouseup', () => isFiring = false);
        document.addEventListener('mouseleave', () => isFiring = false);

        canvas.addEventListener('touchmove', (e) => { 
            e.preventDefault(); 
            handleMove(e.touches[0].clientX, e.touches[0].clientY); 
            // ‰øÆÊ≠£ÔºöÁßªÂãïÊôÇÂº∑Âà∂Ë®≠ÁÇ∫Â∞ÑÊìäÁãÄÊÖã
            isFiring = true; 
        }, { passive: false });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            if (gameState === 'START' || gameState === 'GAMEOVER') return; 
            handleMove(e.touches[0].clientX, e.touches[0].clientY);
            // ‰øÆÊ≠£ÔºöÊåâ‰∏ãÊôÇÂº∑Âà∂Ë®≠ÁÇ∫Â∞ÑÊìäÁãÄÊÖã
            isFiring = true; 
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            // ‰øÆÊ≠£ÔºöÂè™ÊúâÁï∂ÊâÄÊúâÊâãÊåáÈõ¢ÈñãÊôÇÊâçÂÅúÊ≠¢Â∞ÑÊìä
            if (e.touches.length === 0) {
                isFiring = false;
            }
        }, { passive: false });

        document.getElementById('start-btn').onclick = function() {
            unlockAudio();
            startGame();
        };
        document.getElementById('start-btn').ontouchend = (e) => { 
            e.preventDefault(); 
            unlockAudio();
            startGame(); 
        }; 
        
        document.getElementById('restart-btn').onclick = resetToHome;
        document.getElementById('restart-btn').ontouchend = (e) => { e.preventDefault(); resetToHome(); };

        function resetToHome() {
            try {
                if (levelTransitionTimeout) clearTimeout(levelTransitionTimeout);
                gameState = 'START';
                
                if (animationFrameId) cancelAnimationFrame(animationFrameId);

                if(gameOverScreen) gameOverScreen.style.display = 'none'; 
                if(startScreen) startScreen.style.display = 'flex'; 
                if(bossHud) bossHud.style.display = 'none';
                if(collectedEl) collectedEl.innerHTML = ''; 
                if(progressBar) progressBar.style.width = '0%';
                if(scoreEl) scoreEl.innerText = 0;
                if(comboEl) comboEl.innerText = 0;
                if(karmaBar) karmaBar.style.width = '0%';

                if(bgmPlayer) { bgmPlayer.pause(); bgmPlayer.currentTime = 0; }
                
                enemies = []; bullets = []; items = []; floatTexts = []; particles = [];
                waveQueue = []; 
                
                boss = { active: false, x: 0, y: -200, hp: 100, maxHp: 100, weakPoints: [], attackTimer: 0, defeated: false, type: 0, angle: 0, isDying: false, opacity: 1, deathTimer: 0, theme: null };
                
                score = 0; comboCount = 0; 
                player.x = canvas.width / 2; player.y = canvas.height - 110;
                player.targetX = player.x; player.targetY = player.y;
                player.hp = 3; player.karma = 0; 
                updateHP(); updateKarma();
                
                isFiring = false; spreadTimer = 0; freezeTimer = 0;
                spawnTimer = 0;
                obstacleTimer = 0;
                
                resize();
                lastTime = performance.now();
                animationFrameId = requestAnimationFrame(gameLoop);
            } catch(e) {
                console.error("Reset Error:", e);
            }
        }

        function startGame() {
            resetToHome(); 
            gameState = 'PLAYING';
            startScreen.style.display = 'none'; 
            
            if(!isMuted && bgmPlayer) bgmPlayer.play().catch(e => console.log("Audio Play Error:", e));
            
            lastTime = performance.now();
            loadLevel(0); 
        }

        function loadLevel(levelIdx) {
            if (levelIdx >= LEVEL_TEXTS.length) { winGame(); return; }
            currentLevelIndex = levelIdx; currentLevelCharIndex = 0;
            let text = LEVEL_TEXTS[levelIdx];
            waveQueue = text.split('').map((c, i) => ({ char: c, idx: i }));
            boss.defeated = false; 
            levelIndEl.innerText = `Á¨¨ ${levelIdx + 1} Èóú`;
            collectedEl.innerHTML = '';
            progressBar.style.width = '0%'; 
            updateTarget(); gameState = 'PLAYING';
        }

        function updateTarget() {
            let text = LEVEL_TEXTS[currentLevelIndex];
            let progress = (currentLevelCharIndex / text.length) * 100;
            progressBar.style.width = progress + '%';
            if (currentLevelCharIndex < text.length) {
                targetEl.innerText = text[currentLevelCharIndex];
                targetEl.style.transform = "scale(1.3)";
                setTimeout(() => targetEl.style.transform = "scale(1)", 150);
            } else {
                targetEl.innerText = "ÂÆåÊàê";
            }
        }

        function levelComplete() {
            if ((currentLevelIndex + 1) % 3 === 0 && !boss.defeated) { spawnBoss(); return; }
            gameState = 'LEVEL_TRANSITION';
            levelTitle.innerText = `Á¨¨ ${currentLevelIndex + 1} Èóú ÂÆåÊàê`;
            levelScreen.style.display = 'flex';
            
            let fullText = LEVEL_TEXTS[currentLevelIndex];
            const levelSubtitleEl = document.getElementById('level-subtitle');
            if (levelSubtitleEl) {
                levelSubtitleEl.innerText = fullText;
                levelSubtitleEl.style.fontSize = fullText.length > 10 ? '20px' : '24px';
            }
            
            readLevelContent(fullText, () => {
                levelScreen.style.display = 'none'; 
                loadLevel(currentLevelIndex + 1); 
            });
        }

        function shoot() {
            playSound('shoot'); muzzleFlash = 5; 
            const createBullet = (angleOffset) => {
                bullets.push({
                    x: player.x, y: player.y - 30,
                    vx: Math.sin(angleOffset) * 5, vy: -15, width: 32, height: 32, trail: []
                });
            };
            if (comboCount >= 20) { createBullet(0); createBullet(-0.2); createBullet(0.2); } 
            else if (comboCount >= 10) { createBullet(-0.1); createBullet(0.1); } 
            else { createBullet(0); }
            if (spreadTimer > 0) { createBullet(-0.4); createBullet(0.4); }
        }

        function spawnBoss() {
            gameState = 'BOSS'; boss.active = true; boss.x = canvas.width / 2; boss.y = -150; 
            boss.maxHp = 100 + (currentLevelIndex * 20); boss.hp = boss.maxHp;
            boss.type = (currentLevelIndex + 1) / 3; 
            boss.angle = 0;
            boss.isDying = false; boss.opacity = 1; boss.deathTimer = 0;
            boss.theme = BOSS_THEMES[Math.floor(boss.type % BOSS_THEMES.length)];
            
            if (boss.type % 3 === 1) { 
                boss.weakPoints = [{ text: 'Ë≤™', x: 0, y: 0, active: true }, { text: 'Âóî', x: 0, y: 0, active: true }, { text: 'Áô°', x: 0, y: 0, active: true }];
            } else if (boss.type % 3 === 2) { 
                boss.weakPoints = [{ text: 'Áîü', x: 0, y: 0, active: true }, { text: 'ËÄÅ', x: 0, y: 0, active: true }, { text: 'ÁóÖ', x: 0, y: 0, active: true }, { text: 'Ê≠ª', x: 0, y: 0, active: true }];
            } else { 
                boss.weakPoints = [{ text: 'Ëâ≤', x: 0, y: 0, active: true }, { text: 'Âèó', x: 0, y: 0, active: true }, { text: 'ÊÉ≥', x: 0, y: 0, active: true }, { text: 'Ë°å', x: 0, y: 0, active: true }, { text: 'Ë≠ò', x: 0, y: 0, active: true }];
            }
            
            bossHud.style.display = 'flex'; playSound('boss_roar'); triggerShake(20); showFloatingMsg("ÂøÉÈ≠îÁèæË∫´ÔºÅ", 'normal'); enemies = [];
        }

        function checkBossLogic(dt) {
            if (boss.isDying) {
                boss.deathTimer += dt;
                boss.opacity = Math.max(0, 1 - boss.deathTimer / 3000); 
                triggerShake(20);
                if (Math.random() < 0.2) createExplosion(boss.x + (Math.random()-0.5)*100, boss.y + (Math.random()-0.5)*100, '#ff5252', true);
                if (boss.deathTimer > 3000) {
                     boss.active = false; boss.defeated = true; bossHud.style.display = 'none';
                     showFloatingMsg("ÂøÉÈ≠îÂ∑≤Èô§ÔºÅ", 'golden'); enemies = []; levelComplete();
                }
                // Ê≠ª‰∫°ÊôÇË°ÄÊ¢ùÊ≠∏Èõ∂
                bossHpFill.style.width = '0%';
                return; 
            }

            if (!boss.active) return;
            if (boss.y < 150) boss.y += 2;
            
            boss.x = canvas.width/2 + Math.sin(Date.now() * 0.0008) * 120 + Math.cos(Date.now() * 0.002) * 30;
            boss.y += Math.sin(Date.now() * 0.003) * 0.5;
            boss.angle += 0.01;

            const count = boss.weakPoints.length;
            boss.weakPoints.forEach((wp, i) => {
                if (!wp.active) return;
                const breathingRadius = 110 + Math.sin(Date.now() * 0.002) * 10;
                const angle = boss.angle + (i / count) * Math.PI * 2;
                wp.x = boss.x + Math.cos(angle) * breathingRadius;
                wp.y = boss.y + Math.sin(angle) * breathingRadius;
            });

            boss.attackTimer += dt;
            let attackInterval = Math.max(400, 2000 - currentLevelIndex * 50);
            
            if (boss.attackTimer > attackInterval) {
                boss.attackTimer = 0;
                if (boss.type % 3 === 1) { 
                    for (let k = -2; k <= 2; k++) {
                        enemies.push({ x: boss.x, y: boss.y + 50, width: 30, height: 30, type: 'interference_straight', speed: 6, vx: k * 2, char: 'Ê•≠' });
                    }
                } else if (boss.type % 3 === 2) { 
                    for (let k = 0; k < 6; k++) {
                        let a = boss.angle + (k / 6) * Math.PI * 2;
                        enemies.push({ x: boss.x, y: boss.y, width: 30, height: 30, type: 'interference_straight', speed: 5, vx: Math.cos(a)*5, vy: Math.sin(a)*5, char: 'Ëã¶' });
                    }
                } else { 
                    enemies.push({ x: boss.x, y: boss.y + 50, width: 40, height: 40, type: 'interference_chaser', speed: 4, char: 'È≠î' });
                }
            }

            if (boss.weakPoints.every(wp => !wp.active) || boss.hp <= 0) {
                boss.isDying = true;
                playSound('boss_roar');
            }
        }

        function gameLoop(timestamp) {
            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            try {
                const dt = timestamp - lastTime; lastTime = timestamp;
                if (shakeIntensity > 0) shakeIntensity *= 0.9; if (shakeIntensity < 0.5) shakeIntensity = 0;

                ctx.save();
                if (shakeIntensity > 0) ctx.translate((Math.random()-0.5)*shakeIntensity, (Math.random()-0.5)*shakeIntensity);
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // ËÉåÊôØ
                ctx.save();
                const centerX = canvas.width / 2; const centerY = canvas.height / 2;
                
                const planetIdx = Math.floor(currentLevelIndex / 3) % PLANET_COLORS.length;
                const themeColor = PLANET_COLORS[planetIdx][0];
                const bgColor = PLANET_COLORS[planetIdx][1];

                const bgGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, canvas.height);
                bgGrad.addColorStop(0, bgColor); bgGrad.addColorStop(1, '#000');
                ctx.fillStyle = bgGrad; ctx.fillRect(0,0,canvas.width, canvas.height);

                ctx.lineWidth = 1;
                mandalas.forEach(m => {
                    m.angle += m.speed; ctx.strokeStyle = `rgba(255, 255, 255, ${m.opacity})`; 
                    ctx.save(); ctx.translate(centerX, centerY); ctx.rotate(m.angle);
                    ctx.beginPath();
                    for(let i=0; i<=m.points; i++) {
                        const angle = (i / m.points) * Math.PI * 2;
                        if(i===0) ctx.moveTo(Math.cos(angle)*m.radius, Math.sin(angle)*m.radius); else ctx.lineTo(Math.cos(angle)*m.radius, Math.sin(angle)*m.radius);
                    }
                    ctx.closePath(); ctx.stroke(); ctx.restore();
                });

                ctx.globalCompositeOperation = 'lighter'; 
                nebulas.forEach(n => {
                    n.x += n.vx; n.y += n.vy;
                    if(n.x < -200) n.x = canvas.width+200; if(n.x > canvas.width+200) n.x = -200;
                    if(n.y < -200) n.y = canvas.height+200; if(n.y > canvas.height+200) n.y = -200;
                    const grad = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.radius);
                    grad.addColorStop(0, themeColor); grad.addColorStop(1, 'transparent'); 
                    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(n.x, n.y, n.radius, 0, Math.PI*2); ctx.fill();
                });
                
                ctx.globalCompositeOperation = 'source-over';
                stars.forEach(star => {
                    let speed = STAR_SPEED + (currentLevelIndex * 0.2); 
                    if (currentLevelIndex >= 23) speed = 15; if (comboCount > 20) speed += 5; 
                    star.z -= speed;
                    if (star.z <= 0) { star.z = canvas.width; star.x = (Math.random() - 0.5) * canvas.width * 3; star.y = (Math.random() - 0.5) * canvas.height * 3; }
                    const k = 128.0 / star.z; const px = star.x * k + centerX; const py = star.y * k + centerY;
                    if (px >= 0 && px <= canvas.width && py >= 0 && py <= canvas.height) {
                        const size = (1 - star.z / canvas.width) * (star.size || 2);
                        ctx.fillStyle = star.color; ctx.globalAlpha = (1 - star.z / canvas.width);
                        ctx.beginPath(); ctx.arc(px, py, size, 0, Math.PI * 2); ctx.fill();
                    }
                });
                ctx.globalAlpha = 1.0;
                
                spiritDust.forEach(d => {
                    d.y += d.vy; if (d.y < 0) { d.y = canvas.height; d.x = Math.random() * canvas.width; }
                    ctx.fillStyle = `rgba(255, 255, 255, ${d.opacity})`; ctx.beginPath(); ctx.arc(d.x, d.y, d.size, 0, Math.PI*2); ctx.fill();
                });

                if (currentLevelIndex >= 23 || comboCount >= 20) {
                    ctx.globalCompositeOperation = 'overlay'; ctx.fillStyle = 'rgba(255, 215, 0, 0.15)';
                    ctx.fillRect(0,0,canvas.width, canvas.height); ctx.globalCompositeOperation = 'source-over';
                }
                ctx.restore();

                // 2. ÈÇèËºØÊõ¥Êñ∞ - ÁîüÊàêËàáÁßªÂãï
                if (gameState === 'PLAYING' && freezeTimer <= 0) {
                    spawnTimer += dt;
                    let interval = Math.max(400, spawnInterval - (currentLevelIndex * 40)); 
                    
                    if (spawnTimer > interval) {
                        // ÊéâËêΩÈñìË∑ùÊ™¢Êü•
                        let canSpawn = true;
                        if (enemies.length > 0) {
                             const lastEnemy = enemies[enemies.length - 1];
                             if (lastEnemy.y < 150) canSpawn = false; 
                        }

                        if (canSpawn) {
                            spawnTimer = 0;
                            if (waveQueue.length > 0) {
                                const data = waveQueue.shift();
                                const enemyWidth = 70; const margin = canvas.width * 0.15;
                                
                                // Á∂ìÊñáÔºöÂæûÂõõËôïÈö®Ê©üÁîüÊàê
                                const side = Math.floor(Math.random() * 3); // 0:Top, 1:Left, 2:Right
                                let sx, sy;
                                if (side === 0) { sx = Math.random() * (canvas.width - 60) + 30; sy = -70; } 
                                else if (side === 1) { sx = -70; sy = Math.random() * (canvas.height * 0.4); } 
                                else { sx = canvas.width + 70; sy = Math.random() * (canvas.height * 0.4); }

                                // ÁõÆÊ®ôÔºöÁï´Èù¢‰∏≠‰∏ãÂçÄÂüü
                                const tx = canvas.width / 2 + (Math.random() - 0.5) * 200;
                                const ty = canvas.height * 0.7;

                                const angle = Math.atan2(ty - sy, tx - sx);
                                // ÈÄüÂ∫¶Âä†Âø´
                                let dropSpeed = (canvas.height/600) * (2.0 + currentLevelIndex * 0.1); 

                                enemies.push({
                                    x: sx, y: sy, width: 70, height: 70, type: 'text',
                                    char: data.char, idx: data.idx,
                                    vx: Math.cos(angle) * dropSpeed,
                                    vy: Math.sin(angle) * dropSpeed,
                                    angle: 0, rotSpeed: (Math.random()-0.5) * 0.05
                                });
                            } else if (enemies.length === 0) { levelComplete(); }
                        }
                    }

                    // ÈöúÁ§ôÁâ©ÁîüÊàê (Áç®Á´ãË®àÊôÇ)
                    obstacleTimer += dt;
                    let currentObsInterval = Math.max(800, 2000 - currentLevelIndex * 50); 

                    if(obstacleTimer > currentObsInterval) {
                        obstacleTimer = 0;
                        if(Math.random() < 0.6) {
                            const side = Math.floor(Math.random() * 3);
                            let sx, sy;
                            if (side === 0) { sx = Math.random() * canvas.width; sy = -60; } 
                            else if (side === 1) { sx = -60; sy = Math.random() * (canvas.height/2); } 
                            else { sx = canvas.width + 60; sy = Math.random() * (canvas.height/2); }

                            const tx = Math.random() * canvas.width;
                            const ty = canvas.height + 50;

                            const speed = (canvas.height/600) * (3 + currentLevelIndex * 0.15);
                            const angle = Math.atan2(ty - sy, tx - sx);
                            const vx = Math.cos(angle) * speed;
                            const vy = Math.sin(angle) * speed;

                            const obsType = obstacleTypes[Math.floor(Math.random() * obstacleTypes.length)];
                            enemies.push({
                                x: sx, y: sy, width: 70, height: 70, type: 'obstacle_' + obsType,
                                vx: vx, vy: vy,
                                angle: 0, rotSpeed: 0.05
                            });
                        }
                    }
                }

                // ÁßªÂãïËàáÁ¢∞Êíû
                for (let i = enemies.length - 1; i >= 0; i--) {
                    let e = enemies[i];
                    if (freezeTimer <= 0) {
                        if (e.type === 'interference_straight') { e.y += e.speed; if (e.vx) e.x += e.vx; if (e.vy) e.y += e.vy; } 
                        else if (e.type === 'interference_chaser') {
                            let angle = Math.atan2(player.y - e.y, player.x - e.x); e.x += Math.cos(angle) * 3; e.y += Math.sin(angle) * 3;
                        }
                        else if (e.type === 'karma') { e.y += e.speed * 1.5; e.x += Math.sin(e.y*0.05)*2; } 
                        else { 
                            // Á∂ìÊñáËàáÈöúÁ§ôÁâ© ‰ΩøÁî®ÂêëÈáèÁßªÂãï
                            e.x += e.vx; e.y += e.vy; 
                            e.angle += e.rotSpeed || 0;
                        }
                    }

                    // Á¢∞ÊíûÂà§Êñ∑
                    let dist = Math.hypot(player.x - (e.x + 35), player.y - (e.y + 35));
                    if (dist < 40) { 
                        let takeDamage = true;
                        if (hasShield) { 
                            hasShield = false; triggerShake(10); playSound('error'); showFloatingMsg("Ë≠∑ÁõæÁ†¥Á¢é"); takeDamage = false;
                        } else { 
                            player.hp--; updateHP();
                            damageOverlay.style.opacity = 0.8; setTimeout(() => damageOverlay.style.opacity = 0, 200);
                            triggerShake(15); playSound('damage');
                        }

                        // ‰øÆÊîπÔºöÂ¶ÇÊûúÊíûÂà∞ÁöÑÊòØÁ∂ìÊñáÔºåÂΩàÂõûÈáç‰æÜ
                        if (e.type === 'text') {
                            // ÈáçÁΩÆÁÇ∫Âæû‰∏äÊñπÊéâËêΩ (Êá≤ÁΩ∞)
                            e.y = -100; e.x = Math.random() * (canvas.width - 70);
                            e.vx = 0; e.vy = (canvas.height/600) * 2; // ÈáçÁΩÆÁÇ∫ÂûÇÁõ¥ÈÄüÂ∫¶
                            if(score>0 && gameState !== 'GAMEOVER') score = Math.max(0, score - 50); 
                            scoreEl.innerText = score;
                        } else {
                            enemies.splice(i, 1);
                        }

                        if (takeDamage && player.hp <= 0) { gameOver("ÂÆöÂäõ‰∏çË∂≥ÔºåÂøÉÈ≠îÂÖ•‰æµ"); } 
                    }
                    else if (e.y > canvas.height + 100 || e.x < -100 || e.x > canvas.width + 100) {
                         // Ë∂ÖÂá∫ÈÇäÁïåËôïÁêÜ
                        if (e.type === 'text') { 
                            e.y = -100; e.x = Math.random() * (canvas.width - 70);
                            e.vx = 0; e.vy = (canvas.height/600) * 2;
                            if(score>0 && gameState !== 'GAMEOVER') score = Math.max(0, score - 50); 
                            scoreEl.innerText = score;
                            comboEl.innerText = 0;
                        } else { 
                            enemies.splice(i, 1); 
                        }
                    }
                }
                
                // ... (Player logic) ...
                if (gameState === 'PLAYING' || gameState === 'BOSS') {
                    let diffX = player.targetX - player.x;
                    let diffY = player.targetY - player.y; 
                    
                    player.x += diffX * 0.15;
                    player.y += diffY * 0.15; 
                    player.x = Math.max(32, Math.min(canvas.width - 32, player.x));
                    player.y = Math.max(32, Math.min(canvas.height - 32, player.y));
                    
                    player.tilt = Math.max(-0.5, Math.min(0.5, diffX * 0.01)); 
                    player.haloAngle += 0.02;
                    if (spreadTimer > 0) spreadTimer -= dt;
                    if (freezeTimer > 0) freezeTimer -= dt;
                    if (muzzleFlash > 0) muzzleFlash--; 
                    
                    if (Math.abs(diffX) > 2 || Math.abs(diffY) > 2) {
                        particles.push({ x: player.x, y: player.y, size: 30, life: 0.5, color: '#fff176', type: 'trail' });
                    }

                    if (isFiring) {
                        let currentFireInterval = 200;
                        if (comboCount > 10) currentFireInterval = 150;
                        if (comboCount > 20) currentFireInterval = 100;
                        if (spreadTimer > 0) currentFireInterval = 80; 

                        if (timestamp - lastAutoShoot > currentFireInterval) {
                            shoot();
                            lastAutoShoot = timestamp;
                        }
                    }
                }

                // ... (bullets, boss, particles logic same as before) ...
                // ÈÅìÂÖ∑
                for (let i = items.length - 1; i >= 0; i--) {
                    let item = items[i]; item.y += 3;
                    if (Math.hypot(player.x - item.x, player.y - item.y) < 50) {
                        playSound('powerup');
                        if (item.type === 'spread') { spreadTimer = 5000; showFloatingMsg("ÂçÉÊâãËßÄÈü≥!"); }
                        else if (item.type === 'freeze') { freezeTimer = 3000; showFloatingMsg("ÂÆö!"); }
                        else if (item.type === 'shield') { hasShield = true; showFloatingMsg("Ëà¨Ëã•Áõæ!"); }
                        else if (item.type === 'heal') { 
                            if(player.hp < player.maxHp) { player.hp++; updateHP(); showFloatingMsg("ÊÅ¢Âæ©", "heal"); playSound('heal'); }
                        }
                        items.splice(i, 1);
                    } else if (item.y > canvas.height) items.splice(i, 1);
                }

                if (gameState === 'BOSS') {
                    checkBossLogic(dt);
                } 

                for (let i = bullets.length - 1; i >= 0; i--) {
                    let b = bullets[i];
                    b.x += b.vx || 0; b.y += b.vy; b.trail.push({x:b.x, y:b.y}); if(b.trail.length>5) b.trail.shift();
                    if (b.y < -50) bullets.splice(i, 1);
                }

                for (let i = bullets.length - 1; i >= 0; i--) {
                    let b = bullets[i]; let hit = false;
                    if (gameState === 'BOSS' && boss.active) {
                        for (let wp of boss.weakPoints) {
                            if (wp.active && Math.hypot(b.x - wp.x, b.y - wp.y) < 40) {
                                wp.active = false; hit = true; createExplosion(wp.x, wp.y, '#ff5252', true);
                                boss.hp -= 34; bossHpFill.style.width = Math.max(0, (boss.hp/boss.maxHp)*100) + '%';
                                playSound('hit');
                                if (Math.random() > 0.5) items.push({x: wp.x, y: wp.y, type: 'spread'});
                                break;
                            }
                        }
                    }
                    if (!hit) {
                        for (let j = enemies.length - 1; j >= 0; j--) {
                            let e = enemies[j];
                            if (Math.hypot(b.x - (e.x + 35), b.y - (e.y + 35)) < 40) {
                                hit = true;
                                if (e.type.startsWith('interference') || e.type.startsWith('obstacle') || e.type === 'karma') {
                                    createExplosion(e.x+35, e.y+35, '#555', true); enemies.splice(j, 1);
                                    if(e.type === 'karma') {
                                        player.karma += 20; updateKarma();
                                        showFloatingMsg("Ê•≠ÂäõÂ¢ûÂä†", 'crit');
                                    }
                                    if(e.type.startsWith('obstacle')) {
                                        showFloatingMsg("Á†¥Èô§", 'normal');
                                    }
                                } else if (e.idx === currentLevelCharIndex) {
                                    comboCount++; playSound('hit', comboCount); score += 100 + (comboCount * 10);
                                    speakText(e.char);
                                    currentLevelCharIndex++;
                                    floatTexts.push({text: e.char, x: e.x, y: e.y, life: 1.0, scale: 1});
                                    if (comboCount % 20 === 0) items.push({x: e.x, y: e.y, type: 'spread'});
                                    if (comboCount % 35 === 0) items.push({x: e.x, y: e.y, type: 'freeze'});
                                    if (comboCount >= 5 && Math.random() < 0.1 && player.hp < player.maxHp) items.push({x: e.x, y: e.y, type: 'heal'});
                                    
                                    showFloatingMsg("+" + (100 + comboCount*10), 'crit', e.x+35, e.y-20);
                                    
                                    createExplosion(e.x+35, e.y+35, '#ffd700', true);
                                    const span = document.createElement('span'); span.className = 'sutra-char'; span.innerText = e.char; collectedEl.appendChild(span);
                                    collectedEl.scrollTop = collectedEl.scrollHeight;
                                    enemies.splice(j, 1); updateTarget();
                                } else {
                                    // ÊâìÈåØÂ≠ó
                                    if (currentLevelIndex < 23) {
                                        comboCount = 0; score -= 10; playSound('error'); triggerShake(5);
                                        createExplosion(e.x+35, e.y+35, '#ff5252', false);
                                    } else {
                                        createExplosion(e.x+35, e.y+35, '#ffd700', false); enemies.splice(j, 1);
                                    }
                                }
                                scoreEl.innerText = score; comboEl.innerText = comboCount;
                                break;
                            }
                        }
                    }
                    if (hit) bullets.splice(i, 1);
                }

                if (gameState !== 'START') {
                    items.forEach(item => { 
                        let img = freezeImg;
                        if(item.type === 'spread') img = spreadImg;
                        else if(item.type === 'heal') img = healImg;
                        ctx.drawImage(img, item.x-20, item.y-20, 40, 40); 
                    });

                    ctx.save();
                    ctx.translate(player.x, player.y);
                    ctx.rotate(player.haloAngle + player.tilt); ctx.scale(1 - Math.abs(player.tilt)*0.2, 1); 
                    ctx.shadowColor = `rgba(255, 215, 0, ${hasShield ? 0.8 : 0.4})`; ctx.shadowBlur = 15;
                    ctx.strokeStyle = `rgba(255, 215, 0, ${hasShield ? 0.9 : 0.4})`; ctx.lineWidth = hasShield ? 5 : 3;
                    ctx.beginPath(); for(let k=0; k<8; k++) { ctx.moveTo(0,0); ctx.lineTo(60,0); ctx.rotate(Math.PI/4); } ctx.stroke();
                    ctx.beginPath(); ctx.arc(0,0,55,0,Math.PI*2); ctx.stroke(); ctx.shadowBlur = 0;
                    if (hasShield) {
                        ctx.fillStyle = 'rgba(255, 64, 129, 0.4)';
                        for(let k=0; k<6; k++) { ctx.rotate(Math.PI/3); ctx.beginPath(); ctx.ellipse(0, -60, 10, 30, 0, 0, Math.PI*2); ctx.fill(); }
                    }
                    if (muzzleFlash > 0) { ctx.fillStyle = `rgba(255, 255, 200, ${muzzleFlash/5})`; ctx.beginPath(); ctx.arc(0, -50, 40, 0, Math.PI*2); ctx.fill(); }
                    ctx.rotate(-(player.haloAngle + player.tilt)); ctx.rotate(player.tilt);
                    // Áπ™Ë£ΩÈáëÂÖâÊ≥ïËº™
                    ctx.drawImage(playerImg, -32, -32, 64, 64);
                    ctx.restore();

                    ctx.globalCompositeOperation = 'lighter';
                    bullets.forEach(b => {
                        ctx.strokeStyle = 'rgba(255,255,0,0.5)'; ctx.lineWidth=10;
                        ctx.beginPath(); ctx.moveTo(b.trail[0].x, b.trail[0].y); b.trail.forEach(t=>ctx.lineTo(t.x, t.y)); ctx.stroke();
                        ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 10;
                        ctx.drawImage(bulletImg, b.x-16, b.y-16, 32, 32); ctx.shadowBlur = 0;
                    });
                    ctx.globalCompositeOperation = 'source-over';

                    enemies.forEach(e => {
                        ctx.save(); ctx.translate(e.x + 35, e.y + 35); if (e.angle) ctx.rotate(e.angle); 
                        if (e.type.startsWith('interference')) {
                            // Áπ™Ë£ΩÈ≠îÁéãÂΩàÂπï (ÁÅ´ÁÑ∞Â≠ó)
                            const char = e.char || 'Ê•≠';
                            if (bossBulletImgs[char]) {
                                ctx.drawImage(bossBulletImgs[char], -35, -35, 70, 70);
                            } else {
                                // Fallback
                                ctx.fillStyle = '#ff1744'; ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*2); ctx.fill();
                            }
                        } else if (e.type.startsWith('obstacle')) {
                            const typeName = e.type.split('_')[1];
                            if(obstacleImgs[typeName]) {
                                ctx.drawImage(obstacleImgs[typeName], -35, -35, 70, 70);
                            }
                        } else {
                            ctx.drawImage(lotusImg, -35, -35, 70, 70);
                            if (e.idx === currentLevelCharIndex) {
                                ctx.strokeStyle = '#ffd700'; ctx.lineWidth=3; ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 20; 
                                let scale = 1 + Math.sin(timestamp*0.01)*0.1; ctx.scale(scale, scale);
                                ctx.beginPath(); ctx.arc(0, 0, 38, 0, Math.PI*2); ctx.stroke(); ctx.scale(1/scale, 1/scale); ctx.shadowBlur = 0;
                            }
                            ctx.font = "bold 30px 'Ma Shan Zheng'"; ctx.textAlign="center"; ctx.textBaseline="middle";
                            ctx.fillStyle = (e.idx === currentLevelCharIndex) ? '#ffd700' : '#fff';
                            ctx.shadowColor = 'black'; ctx.shadowBlur = 4; ctx.fillText(e.char, 0, 3);
                        }
                        ctx.restore();
                    });

                    if (gameState === 'BOSS' && boss.active) {
                        ctx.save(); ctx.translate(boss.x, boss.y);
                        
                        ctx.globalAlpha = boss.opacity;

                        // Á¢∫‰øù theme Â≠òÂú®
                        const theme = boss.theme || BOSS_THEMES[0];

                        // --- ÈáçÊñ∞Ë®≠Ë®àÁöÑÈ≠îÁéã (‰øÆÁæÖÈ¨ºÈù¢) ---
                        // ÂÖâËº™
                        ctx.save(); ctx.rotate(timestamp * 0.001);
                        const ringGrad = ctx.createRadialGradient(0, 0, 60, 0, 0, 140);
                        ringGrad.addColorStop(0, 'rgba(100, 0, 0, 0)');
                        ringGrad.addColorStop(0.5, theme.glow); // ‰ΩøÁî®‰∏ªÈ°åËâ≤ÂÖâÊöà
                        ringGrad.addColorStop(1, 'rgba(50, 0, 0, 0)');
                        ctx.fillStyle = ringGrad; 
                        ctx.beginPath(); 
                        for(let i=0; i<8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            ctx.lineTo(Math.cos(angle)*140, Math.sin(angle)*140);
                            ctx.lineTo(Math.cos(angle + 0.4)*80, Math.sin(angle + 0.4)*80);
                        }
                        ctx.closePath(); ctx.fill(); ctx.restore();

                        // È¨ºÈù¢Êú¨È´î (Ëâ≤Ë™øËÆäÂåñ)
                        const maskGrad = ctx.createLinearGradient(-40, -60, 40, 60);
                        maskGrad.addColorStop(0, theme.light); 
                        maskGrad.addColorStop(0.5, theme.main); 
                        maskGrad.addColorStop(1, '#1a0000');
                        ctx.shadowColor = theme.glow; ctx.shadowBlur = 40; 
                        ctx.fillStyle = maskGrad;
                        ctx.beginPath();
                        ctx.moveTo(-50, -40); ctx.quadraticCurveTo(-70, 0, -40, 60); 
                        ctx.quadraticCurveTo(0, 90, 40, 60); ctx.quadraticCurveTo(70, 0, 50, -40); 
                        ctx.quadraticCurveTo(0, -70, -50, -40); ctx.fill(); ctx.shadowBlur = 0;

                        // ÈõôËßí
                        const hornGrad = ctx.createLinearGradient(0, -60, 0, -100);
                        hornGrad.addColorStop(0, '#1a0000'); hornGrad.addColorStop(1, '#ffab00');
                        ctx.fillStyle = hornGrad;
                        ctx.beginPath(); ctx.moveTo(-40, -50); ctx.quadraticCurveTo(-60, -90, -30, -110); ctx.quadraticCurveTo(-20, -80, -30, -55); ctx.fill();
                        ctx.beginPath(); ctx.moveTo(40, -50); ctx.quadraticCurveTo(60, -90, 30, -110); ctx.quadraticCurveTo(20, -80, 30, -55); ctx.fill();

                        // ‰∫îÂÆò
                        ctx.fillStyle = '#ffff00'; ctx.shadowColor = '#ffff00'; ctx.shadowBlur = 15;
                        ctx.beginPath(); ctx.ellipse(-25, -10, 10, 6, 0.3, 0, Math.PI*2); ctx.fill();
                        ctx.beginPath(); ctx.ellipse(25, -10, 10, 6, -0.3, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
                        
                        ctx.fillStyle = theme.light; ctx.beginPath(); ctx.arc(0, -35, 6, 0, Math.PI*2); ctx.fill();
                        
                        ctx.fillStyle = '#eee';
                        ctx.beginPath(); ctx.moveTo(-20, 40); ctx.quadraticCurveTo(-22, 60, -15, 50); ctx.fill();
                        ctx.beginPath(); ctx.moveTo(20, 40); ctx.quadraticCurveTo(22, 60, 15, 50); ctx.fill();
                        
                        // Âò¥Á∏´
                        ctx.strokeStyle = '#222'; ctx.lineWidth = 3;
                        ctx.beginPath(); ctx.moveTo(-25, 40); ctx.quadraticCurveTo(0, 50, 25, 40); ctx.stroke();

                        ctx.restore();

                        // Âº±Èªû (È¨ºÁÅ´)
                        boss.weakPoints.forEach((wp, index) => {
                            if (wp.active) {
                                ctx.save(); ctx.translate(wp.x, wp.y);
                                ctx.globalAlpha = boss.opacity; // Á¢∫‰øùÂº±Èªû‰πüË∑üËëóÈÄèÊòé
                                ctx.shadowColor = theme.glow; ctx.shadowBlur = 20;
                                const wpGrad = ctx.createRadialGradient(-5, -5, 2, 0, 0, 35);
                                wpGrad.addColorStop(0, '#ffffff'); wpGrad.addColorStop(0.3, theme.light); wpGrad.addColorStop(1, theme.main);
                                ctx.fillStyle = wpGrad; ctx.beginPath(); ctx.arc(0, 0, 35, 0, Math.PI*2); ctx.fill();
                                
                                ctx.shadowBlur = 0; ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 2;
                                ctx.beginPath(); 
                                ctx.arc(0, 0, 40 + Math.sin(timestamp * 0.01 + index)*5, 0, Math.PI*2); 
                                ctx.stroke();

                                ctx.fillStyle = '#fff'; ctx.font = "bold 32px 'Ma Shan Zheng'"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(wp.text, 0, 2);
                                ctx.restore();
                            }
                        });
                        
                        ctx.globalAlpha = 1.0; // ÈÇÑÂéüÈÄèÊòéÂ∫¶
                    }

                    for (let i = floatTexts.length - 1; i >= 0; i--) {
                        let ft = floatTexts[i]; ft.life -= 0.04; if (ft.life <= 0) { floatTexts.splice(i, 1); continue; }
                        ctx.save(); ctx.translate(ft.x + 35, ft.y + 35);
                        let s = 1 + (1-ft.life) * 0.5; ctx.scale(s, s); ctx.globalAlpha = ft.life;
                        ctx.fillStyle = '#ffd700'; ctx.shadowColor = '#ff6f00'; ctx.shadowBlur = 20;
                        ctx.font = "bold 60px 'Ma Shan Zheng'"; ctx.fillText(ft.text, 0, 0); ctx.restore();
                    }
                }

                particles.forEach((p, i) => {
                    p.life -= 0.03; p.x += p.vx; p.y += p.vy;
                    ctx.globalAlpha = p.life;
                    if (p.type === 'trail') {
                        ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI*2); ctx.fill();
                    } else if (p.type === 'shockwave') {
                        ctx.strokeStyle = p.color; ctx.lineWidth = 5 * p.life; p.size += 5; 
                        ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.stroke();
                    } else {
                        ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle = p.color;
                        ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                        ctx.globalCompositeOperation = 'source-over';
                    }
                    if (p.life<=0) particles.splice(i,1);
                });
                ctx.globalAlpha = 1.0;
                ctx.restore(); 
            } catch (e) {
                console.error("Game Loop Error:", e);
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        // ÂïüÂãïÈÅäÊà≤
        resize();
        animationFrameId = requestAnimationFrame(gameLoop);
    })();
</script>
</body>
</html>