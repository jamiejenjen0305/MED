<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>微笑心經：星際大冒險</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Serif+TC:wght@500;900&display=swap');

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505; /* 外部背景全黑 */
            font-family: 'Noto Serif TC', serif;
            user-select: none;
            /* 讓遊戲畫面置中 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none; /* 防止手機瀏覽器預設觸控行為 */
        }

        #game-container {
            position: relative;
            width: 100%;
            max-width: 600px; /* 限制電腦版最大寬度，避免太寬 */
            height: 100%;
            /* 背景基礎色，動態星雲會在 Canvas 繪製 */
            background: radial-gradient(circle at bottom, #1a1025 0%, #000000 100%);
            cursor: none;
            overflow: hidden;
            /* 增加陰影讓畫面與外部區隔 */
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.8), 0 0 10px rgba(255, 255, 255, 0.1); 
        }

        canvas {
            display: block;
        }

        /* UI 層優化：統一配色，減少雜亂 */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            /* 標籤文字改為白色，陰影統一 */
            color: #eeeeee;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .hud-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .hud-label {
            font-size: 20px;
            font-family: 'Noto Serif TC', serif;
            color: #b0b0b0; /* 標籤用灰色，不搶眼 */
        }

        .hud-value {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 28px;
        }

        #level-indicator { 
            font-size: 32px; 
            color: #ffd700; 
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            font-family: 'Ma Shan Zheng', cursive;
            margin-bottom: 5px;
        }
        
        #score { color: #ffffff; }
        #combo { 
            color: #ff4081; 
            font-size: 32px;
            text-shadow: 0 0 8px rgba(255, 64, 129, 0.6); 
            transition: transform 0.1s; 
            display: inline-block; 
        }
        
        /* 目標字特別設計 */
        #target-container {
            display: flex;
            align-items: center;
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.4);
            padding: 5px 15px;
            border-radius: 30px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            width: fit-content;
        }

        #next-target {
            color: #ffd700; /* 金色 */
            font-size: 42px;
            font-weight: bold;
            margin-left: 10px;
            text-shadow: 0 0 15px #ffd700;
        }
        
        #start-screen, #game-over-screen, #level-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6); /* 稍微調亮一點 */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 20;
            cursor: default;
            backdrop-filter: blur(10px);
            padding: 20px; /* 增加內距避免文字貼邊 */
            box-sizing: border-box;
        }

        /* 關卡轉場畫面 */
        #level-screen {
            background: rgba(20, 0, 30, 0.6);
            display: none;
            z-index: 15;
            animation: fadeIn 0.5s;
        }

        h1 {
            font-family: 'Ma Shan Zheng', cursive;
            /* 使用 clamp 讓字體在手機(最小30px)到電腦(最大60px)間自動調整 */
            font-size: clamp(30px, 8vw, 60px);
            /* 標題改為較為穩重的金橙漸層 */
            background: linear-gradient(to bottom, #ffe082, #ff6f00);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0;
            filter: drop-shadow(0 0 20px rgba(255, 111, 0, 0.6));
            animation: floatTitle 3s infinite ease-in-out;
            text-align: center; /* 確保窄畫面時置中 */
            line-height: 1.3;
            width: 100%;
            padding: 0 10px;
        }

        @keyframes floatTitle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        .btn {
            margin-top: 40px;
            padding: 12px 45px;
            font-size: 26px;
            /* 按鈕改為深紫配金，更有質感 */
            background: linear-gradient(135deg, #4a148c, #311b92);
            color: #ffd700;
            border: 2px solid #ffd700;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Ma Shan Zheng', cursive;
            transition: all 0.3s;
            text-decoration: none;
            box-shadow: 0 0 15px rgba(74, 20, 140, 0.6);
            white-space: nowrap; /* 防止按鈕文字換行 */
        }

        .btn:hover {
            transform: scale(1.05);
            background: linear-gradient(135deg, #6a1b9a, #4a148c);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.4);
            color: #fff;
        }

        /* 經文收集區：畫面下方 */
        #collected-sutra {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: auto;
            min-height: 90px;
            max-height: 160px;
            /* 改為深紫金色漸層，更有神祕感與高級感 */
            background: linear-gradient(to top, rgba(20, 10, 30, 0.95), rgba(20, 10, 30, 0.2));
            border-top: 1px solid rgba(255, 215, 0, 0.4);
            
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-end;
            
            padding: 10px 20px 25px 20px;
            pointer-events: none;
            z-index: 5;
            box-sizing: border-box;
            overflow: hidden;
        }

        .sutra-char {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 34px;
            color: #ffd700; /* 純金 */
            margin: 0 3px;
            opacity: 0;
            display: inline-block;
            transform: translateY(20px) scale(1.5);
            animation: floatUpChar 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            /* 增加外發光讓字更立體 */
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
        }

        @keyframes floatUpChar {
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        .instruction {
            margin-top: 25px;
            color: #e0e0e0;
            font-size: 18px;
            line-height: 1.8;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.3);
            padding: 15px 30px;
            border-radius: 10px;
            width: 90%;
            max-width: 400px;
        }
        
        .floating-msg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 50px;
            color: #ff4081;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            opacity: 0;
            pointer-events: none;
            animation: floatUp 1.5s ease-out;
            z-index: 100;
            white-space: nowrap;
        }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            20% { transform: translate(-50%, -60%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -100%) scale(1); }
        }

        /* Boss 血條 */
        #boss-hud {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%; /* 手機/窄版寬度調整 */
            max-width: 400px;
            display: none;
            flex-direction: column;
            align-items: center;
            /* 增加背景底板 */
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 23, 68, 0.3);
        }
        #boss-name {
            font-family: 'Ma Shan Zheng', cursive;
            color: #ff5252;
            font-size: 28px;
            text-shadow: 0 0 10px #b71c1c;
            margin-bottom: 5px;
        }
        #boss-hp-bar {
            width: 100%;
            height: 8px;
            background: #222;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: inset 0 0 5px #000;
        }
        #boss-hp-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff1744, #ff5252);
            transition: width 0.2s;
            box-shadow: 0 0 10px #ff1744;
        }

        #level-title {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 60px;
            color: #ffd700;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff6f00;
            text-align: center;
        }
        #level-subtitle {
            font-family: 'Noto Serif TC', serif;
            font-size: 24px;
            color: #ddd;
            letter-spacing: 2px;
            text-align: center;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-layer">
        <div id="level-indicator">第 1 關</div>
        
        <div class="hud-row">
            <span class="hud-label">功德</span>
            <span class="hud-value" id="score">0</span>
        </div>
        
        <div class="hud-row">
            <span class="hud-label">連擊</span>
            <span class="hud-value" id="combo">0</span>
        </div>
        
        <div id="target-container">
            <span class="hud-label">下一字</span>
            <span class="hud-value" id="next-target">-</span>
        </div>
    </div>

    <div id="boss-hud">
        <div id="boss-name">五蘊心魔</div>
        <div id="boss-hp-bar"><div id="boss-hp-fill"></div></div>
    </div>

    <div id="collected-sutra"></div>

    <div id="start-screen">
        <h1>微笑心經：星際大冒險</h1>
        <div class="instruction">
            <p><strong>操作：</strong>左右滑動移動 | 輕點螢幕發射</p>
            <p><strong>關卡：</strong>共 25 關，循序漸進修煉心經</p>
            <p><strong>道具：</strong>「定」字暫停 | 金蓮花散射</p>
            <p><strong>背景音樂：</strong>請開啟音效享受禪意</p>
        </div>
        <button class="btn" id="start-btn">開始修煉</button>
    </div>

    <!-- 關卡轉場 -->
    <div id="level-screen">
        <div id="level-title">第 1 關 完成</div>
        <div id="level-subtitle">準備進入下一層境界...</div>
    </div>

    <div id="game-over-screen" style="display: none;">
        <h1 id="end-title">修行未果</h1>
        <p id="end-reason" style="font-size: 28px; color: #ff6b6b; margin-bottom: 20px; text-shadow: 0 0 10px red;"></p>
        <p class="instruction">最終功德: <span id="final-score">0</span></p>
        <button class="btn" id="restart-btn">重新來過</button>
    </div>
</div>

<!-- 固定的背景音樂 -->
<audio id="bgm-player" loop src="https://jamiejenjen0305.github.io/MED/meditation-background-434654.mp3"></audio>

<script>
    // --- 遊戲圖檔生成器 ---
    function createTexture(type) {
        const tmpCanvas = document.createElement('canvas');
        const tmpCtx = tmpCanvas.getContext('2d');
        tmpCanvas.width = 64;
        tmpCanvas.height = 64;

        if (type === 'player') {
            // 改成笑臉造型
            const grad = tmpCtx.createRadialGradient(32, 32, 5, 32, 32, 30);
            grad.addColorStop(0, '#fff176'); // 亮黃中心
            grad.addColorStop(1, '#fbc02d'); // 深黃邊緣
            
            // 臉蛋
            tmpCtx.fillStyle = grad;
            tmpCtx.beginPath(); tmpCtx.arc(32, 32, 28, 0, Math.PI * 2); tmpCtx.fill();
            
            // 邊框
            tmpCtx.lineWidth = 2; tmpCtx.strokeStyle = '#f57f17'; tmpCtx.stroke();
            
            // 眼睛 (橢圓)
            tmpCtx.fillStyle = '#3e2723';
            tmpCtx.beginPath();
            tmpCtx.ellipse(22, 25, 3, 5, 0, 0, Math.PI*2); // 左眼
            tmpCtx.ellipse(42, 25, 3, 5, 0, 0, Math.PI*2); // 右眼
            tmpCtx.fill();
            
            // 微笑 (圓弧)
            tmpCtx.lineWidth = 3; tmpCtx.strokeStyle = '#3e2723'; tmpCtx.lineCap = 'round';
            tmpCtx.beginPath(); tmpCtx.arc(32, 35, 12, 0.1 * Math.PI, 0.9 * Math.PI); tmpCtx.stroke();
            
            // 紅暈 (臉頰)
            tmpCtx.fillStyle = 'rgba(255, 82, 82, 0.5)';
            tmpCtx.beginPath(); tmpCtx.arc(16, 35, 5, 0, Math.PI*2); tmpCtx.fill();
            tmpCtx.beginPath(); tmpCtx.arc(48, 35, 5, 0, Math.PI*2); tmpCtx.fill();

            // 亮點 (高光)
            tmpCtx.fillStyle = 'rgba(255, 255, 255, 0.8)'; 
            tmpCtx.beginPath(); tmpCtx.arc(20, 18, 5, 0, Math.PI*2); tmpCtx.fill();

        } else if (type === 'enemy') {
            // 隕石稍微亮一點，帶一點紫色紋理
            const grad = tmpCtx.createRadialGradient(20, 20, 5, 32, 32, 35);
            grad.addColorStop(0, '#9e9e9e');
            grad.addColorStop(0.5, '#616161');
            grad.addColorStop(1, '#212121');
            
            tmpCtx.fillStyle = grad; 
            tmpCtx.shadowColor = '#7e57c2'; // 淺紫色光暈
            tmpCtx.shadowBlur = 15;
            
            tmpCtx.beginPath();
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const r = 24 + Math.random() * 6; // 稍微圓潤一點
                tmpCtx[i===0?'moveTo':'lineTo'](32 + Math.cos(angle) * r, 32 + Math.sin(angle) * r);
            }
            tmpCtx.closePath(); tmpCtx.fill();
            
            // 紋理
            tmpCtx.fillStyle = 'rgba(0,0,0,0.2)';
            tmpCtx.beginPath(); tmpCtx.arc(20, 25, 4, 0, Math.PI*2); tmpCtx.fill();
            tmpCtx.beginPath(); tmpCtx.arc(45, 35, 6, 0, Math.PI*2); tmpCtx.fill();

        } else if (type === 'bullet') {
            tmpCtx.font = "bold 44px 'Ma Shan Zheng'";
            tmpCtx.textAlign = "center"; tmpCtx.textBaseline = "middle";
            tmpCtx.fillStyle = '#ffff00'; 
            tmpCtx.shadowColor = '#fff'; tmpCtx.shadowBlur = 10;
            tmpCtx.fillText("卍", 32, 34);
        
        } else if (type === 'powerup_spread') {
            // 更精緻的蓮花
            tmpCtx.fillStyle = '#ffca28';
            tmpCtx.beginPath();
            for(let i=0; i<8; i++) {
                let angle = i * Math.PI / 4;
                tmpCtx.ellipse(32 + Math.cos(angle)*18, 32 + Math.sin(angle)*18, 6, 12, angle, 0, Math.PI*2);
            }
            tmpCtx.fill();
            tmpCtx.beginPath(); tmpCtx.arc(32,32,12,0,Math.PI*2); tmpCtx.fillStyle='#fff9c4'; tmpCtx.fill();

        } else if (type === 'powerup_freeze') {
            tmpCtx.fillStyle = '#00e5ff'; // 亮青色
            tmpCtx.shadowColor = '#00e5ff'; tmpCtx.shadowBlur = 10;
            tmpCtx.beginPath(); tmpCtx.arc(32,32,25,0,Math.PI*2); tmpCtx.fill();
            tmpCtx.fillStyle = '#000'; tmpCtx.font = "bold 32px 'Ma Shan Zheng'";
            tmpCtx.textAlign="center"; tmpCtx.textBaseline="middle"; tmpCtx.fillText("定", 32, 34);
        }

        return tmpCanvas.toDataURL('image/png');
    }

    // --- 資源 ---
    const playerImg = new Image(); playerImg.src = createTexture('player');
    const enemyImg = new Image(); enemyImg.src = createTexture('enemy');
    const bulletImg = new Image(); bulletImg.src = createTexture('bullet');
    const spreadImg = new Image(); spreadImg.src = createTexture('powerup_spread');
    const freezeImg = new Image(); freezeImg.src = createTexture('powerup_freeze');

    // --- 關卡資料 ---
    const LEVEL_TEXTS = [
        "觀自在菩薩行深般若波羅蜜多時",
        "照見五蘊皆空度一切苦厄",
        "舍利子色不異空空不異色",
        "色即是空空即是色",
        "受想行識亦復如是",
        "舍利子是諸法空相",
        "不生不滅不垢不淨不增不減",
        "是故空中無色無受想行識",
        "無眼耳鼻舌身意無色聲香味觸法",
        "無眼界乃至無意識界",
        "無無明亦無無明盡",
        "乃至無老死亦無老死盡",
        "無苦集滅道無智亦無得以無所得故",
        "菩提薩埵依般若波羅蜜多故",
        "心無罣礙無罣礙故無有恐怖",
        "遠離顛倒夢想究竟涅槃",
        "三世諸佛依般若波羅蜜多故",
        "得阿耨多羅三藐三菩提",
        "故知般若波羅蜜多",
        "是大神咒是大明咒",
        "是無上咒是無等等咒",
        "能除一切苦真實不虛",
        "故說般若波羅蜜多咒即說咒曰",
        "揭諦揭諦波羅揭諦",
        "波羅僧揭諦菩提薩婆訶"
    ];

    // --- DOM 元素 ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const comboEl = document.getElementById('combo');
    const targetEl = document.getElementById('next-target');
    const levelIndEl = document.getElementById('level-indicator');
    const collectedEl = document.getElementById('collected-sutra');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const levelScreen = document.getElementById('level-screen');
    const levelTitle = document.getElementById('level-title');
    const bossHud = document.getElementById('boss-hud');
    const bossHpFill = document.getElementById('boss-hp-fill');
    const bgmPlayer = document.getElementById('bgm-player');

    // --- 遊戲變數 ---
    let gameState = 'START'; 
    let score = 0;
    let comboCount = 0;
    
    let currentLevelIndex = 0;
    let currentLevelCharIndex = 0;
    
    const player = { x: 0, y: 0, width: 64, height: 64, targetX: 0, haloAngle: 0 };
    let hasShield = false;
    let spreadTimer = 0; 
    let freezeTimer = 0; 
    let shakeIntensity = 0; 

    // 物件池
    let enemies = [];
    let bullets = [];
    let particles = [];
    let floatTexts = []; 
    let items = []; 
    let bgParticles = { stars: [], nebulas: [], meteors: [] }; 

    let boss = { active: false, x: 0, y: -200, hp: 100, maxHp: 100, weakPoints: [], attackTimer: 0, defeated: false };
    const BOSS_LEVEL_TRIGGER = 10; 

    let lastTime = 0;
    let spawnTimer = 0;
    const spawnInterval = 1500;
    let waveQueue = [];

    // --- 音效 (SFX) ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    const audioCtx = new AudioContext();
    const PENTATONIC_SCALE = [
        261.63, 293.66, 329.63, 392.00, 440.00, 
        523.25, 587.33, 659.25, 783.99, 880.00, 
        1046.50 
    ];

    function playSound(type, combo = 0) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;

        if (type === 'hit') {
            osc.type = 'sine';
            let noteIndex = Math.min(combo, PENTATONIC_SCALE.length - 1);
            let freq = PENTATONIC_SCALE[noteIndex];
            osc.frequency.setValueAtTime(freq, now);
            osc.frequency.exponentialRampToValueAtTime(freq, now + 0.1); 
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.start(); osc.stop(now + 0.3);
        } else if (type === 'shoot') {
            osc.type = 'triangle'; 
            osc.frequency.setValueAtTime(spreadTimer > 0 ? 800 : 600, now);
            osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
            gain.gain.setValueAtTime(0.05, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            osc.start(); osc.stop(now + 0.15);
        } else if (type === 'error') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.linearRampToValueAtTime(50, now + 0.3);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.linearRampToValueAtTime(0.01, now + 0.3);
            osc.start(); osc.stop(now + 0.3);
        } else if (type === 'powerup') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(523, now);
            osc.frequency.linearRampToValueAtTime(1046, now + 0.3);
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.linearRampToValueAtTime(0.01, now + 0.5);
            osc.start(); osc.stop(now + 0.5);
        } else if (type === 'boss_roar') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(80, now);
            osc.frequency.linearRampToValueAtTime(40, now + 1.0);
            gain.gain.setValueAtTime(0.5, now);
            gain.gain.linearRampToValueAtTime(0.01, now + 1.0);
            osc.start(); osc.stop(now + 1.0);
        }
    }

    // --- 視覺與系統 ---

    function triggerShake(intensity) {
        shakeIntensity = intensity;
    }

    function initUniverse() {
        bgParticles.stars = [];
        bgParticles.nebulas = []; // 新增星雲
        bgParticles.meteors = [];

        // 星星
        for (let i = 0; i < 150; i++) {
            bgParticles.stars.push({
                x: Math.random() * canvas.width, y: Math.random() * canvas.height,
                size: Math.random() * 1.8, 
                opacity: Math.random(),
                flicker: 0.01 + Math.random() * 0.04
            });
        }
        
        // 星雲 (隨機的大型柔和光斑)
        for (let i = 0; i < 6; i++) {
            bgParticles.nebulas.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: 100 + Math.random() * 200,
                color: `hsla(${Math.random() * 60 + 240}, 60%, 50%, 0.15)`, // 藍紫色系
                vx: (Math.random() - 0.5) * 0.2,
                vy: (Math.random() - 0.5) * 0.2
            });
        }
    }

    function spawnMeteor() {
        if (Math.random() > 0.02) return; // 低機率生成
        bgParticles.meteors.push({
            x: Math.random() * canvas.width,
            y: 0,
            vx: -5 - Math.random() * 5,
            vy: 5 + Math.random() * 5,
            len: 50 + Math.random() * 50,
            life: 1.0
        });
    }

    function showFloatingMsg(text, type = 'normal', x, y) {
        const div = document.createElement('div');
        div.className = 'floating-msg';
        div.innerText = text;
        // 確保浮動文字在容器內
        const container = document.getElementById('game-container');
        if (x && y) { 
            // 簡單限制邊界
            x = Math.max(0, Math.min(x, container.clientWidth));
            div.style.left = x + 'px'; 
            div.style.top = y + 'px'; 
        }
        if (type === 'golden') { div.style.color = '#ffd700'; div.style.fontSize = '60px'; div.style.textShadow = '0 0 30px #ffd700'; }
        container.appendChild(div);
        setTimeout(() => div.remove(), 1500);
    }

    // --- 核心邏輯 ---

    function resize() {
        // 修改這裡：跟隨 #game-container 大小，而不是 window
        const container = document.getElementById('game-container');
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        
        player.y = canvas.height - 110; 
        player.x = canvas.width / 2;
        initUniverse();
    }
    window.addEventListener('resize', resize);
    
    // 滑鼠事件
    document.addEventListener('mousemove', (e) => { 
        if (gameState === 'PLAYING' || gameState === 'BOSS') {
            // 需要校正滑鼠位置，因為 canvas 可能不是全螢幕了
            const rect = canvas.getBoundingClientRect();
            player.targetX = e.clientX - rect.left;
        }
    });
    
    document.addEventListener('mousedown', (e) => { if (gameState === 'PLAYING' || gameState === 'BOSS') shoot(); });

    // --- 新增：手機觸控事件 ---
    let touchStartX = 0;
    let touchStartY = 0;
    let touchStartTime = 0;

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault(); 
        if (gameState === 'PLAYING' || gameState === 'BOSS') {
            // 校正觸控位置
            const rect = canvas.getBoundingClientRect();
            player.targetX = e.touches[0].clientX - rect.left;
        }
    }, { passive: false });

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (gameState === 'START' || gameState === 'GAMEOVER') return; 
        
        if (gameState === 'PLAYING' || gameState === 'BOSS') {
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            
            player.targetX = touchX;
            
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartTime = Date.now();
        }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        if (gameState === 'PLAYING' || gameState === 'BOSS') {
            const touch = e.changedTouches[0];
            const dx = touch.clientX - touchStartX;
            const dy = touch.clientY - touchStartY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const duration = Date.now() - touchStartTime;

            if (distance < 30 && duration < 500) {
                shoot();
            }
        }
    }, { passive: false });
    // ---------------------------

    document.getElementById('start-btn').onclick = startGame;
    document.getElementById('start-btn').ontouchend = (e) => { e.preventDefault(); startGame(); }; 

    document.getElementById('restart-btn').onclick = startGame;
    document.getElementById('restart-btn').ontouchend = (e) => { e.preventDefault(); startGame(); };

    function startGame() {
        score = 0; comboCount = 0; 
        currentLevelIndex = 0;
        hasShield = false; spreadTimer = 0; freezeTimer = 0;
        enemies = []; bullets = []; particles = []; waveQueue = []; items = []; floatTexts = [];
        
        boss.active = false; boss.defeated = false; bossHud.style.display = 'none';
        
        scoreEl.innerText = 0; comboEl.innerText = 0; collectedEl.innerHTML = '';
        startScreen.style.display = 'none'; gameOverScreen.style.display = 'none';
        
        // 播放音樂
        bgmPlayer.play().catch(e => console.log("需使用者互動才能播放音樂"));

        // 確保尺寸正確
        resize();
        
        loadLevel(0);
        lastTime = performance.now();
        // 取消這裡的 requestAnimationFrame，因為已經在最後一行啟動了 Loop
        // 這裡只需要重置狀態
    }

    function loadLevel(levelIdx) {
        if (levelIdx >= LEVEL_TEXTS.length) {
            winGame();
            return;
        }

        currentLevelIndex = levelIdx;
        currentLevelCharIndex = 0;
        
        let text = LEVEL_TEXTS[levelIdx];
        waveQueue = text.split('').map((c, i) => ({ char: c, idx: i }));
        
        levelIndEl.innerText = `第 ${levelIdx + 1} 關`;
        collectedEl.innerHTML = '';
        
        updateTarget();
        gameState = 'PLAYING';
    }

    function updateTarget() {
        let text = LEVEL_TEXTS[currentLevelIndex];
        if (currentLevelCharIndex < text.length) {
            targetEl.innerText = text[currentLevelCharIndex];
            // 讓目標字稍微跳動一下
            targetEl.style.transform = "scale(1.3)";
            setTimeout(() => targetEl.style.transform = "scale(1)", 150);
        } else {
            targetEl.innerText = "完成";
        }
    }

    function levelComplete() {
        if (currentLevelIndex === BOSS_LEVEL_TRIGGER && !boss.defeated) {
            spawnBoss();
            return;
        }

        gameState = 'LEVEL_TRANSITION';
        levelTitle.innerText = `第 ${currentLevelIndex + 1} 關 完成`;
        levelScreen.style.display = 'flex';
        
        setTimeout(() => {
            levelScreen.style.display = 'none';
            loadLevel(currentLevelIndex + 1);
        }, 2000);
    }

    function shoot() {
        playSound('shoot');
        const createBullet = (angleOffset) => {
            bullets.push({
                x: player.x, y: player.y - 30,
                vx: Math.sin(angleOffset) * 5, vy: -15, 
                width: 32, height: 32, trail: []
            });
        };

        createBullet(0);
        if (spreadTimer > 0) {
            createBullet(-0.3); 
            createBullet(0.3);  
        }
    }

    function spawnBoss() {
        gameState = 'BOSS';
        boss.active = true;
        boss.x = canvas.width / 2;
        boss.y = -150;
        boss.hp = 100;
        boss.weakPoints = [
            { text: '貪', x: 0, y: 0, active: true },
            { text: '嗔', x: 0, y: 0, active: true },
            { text: '癡', x: 0, y: 0, active: true }
        ];
        bossHud.style.display = 'flex';
        playSound('boss_roar');
        triggerShake(20);
        showFloatingMsg("心魔現身！消除貪嗔癡！", 'normal');
        enemies = [];
    }

    function checkBossLogic(dt) {
        if (!boss.active) return;
        
        if (boss.y < 100) boss.y += 2;
        boss.x = canvas.width/2 + Math.sin(Date.now() * 0.001) * 150;

        const time = Date.now() * 0.002;
        boss.weakPoints.forEach((wp, i) => {
            if (!wp.active) return;
            const angle = time + (i * (Math.PI * 2 / 3));
            wp.x = boss.x + Math.cos(angle) * 100;
            wp.y = boss.y + Math.sin(angle) * 60;
        });

        boss.attackTimer += dt;
        if (boss.attackTimer > 2000) {
            boss.attackTimer = 0;
            enemies.push({
                x: boss.x, y: boss.y + 50, width: 40, height: 40,
                type: 'interference', 
                speed: 5,
                angle: 0, rotSpeed: 0.1 // 增加旋轉參數
            });
        }
    }

    function gameLoop(timestamp) {
        // if (gameState === 'GAMEOVER') return; // 移除這行，讓背景動畫持續

        const dt = timestamp - lastTime;
        lastTime = timestamp;

        if (shakeIntensity > 0) shakeIntensity *= 0.9;
        if (shakeIntensity < 0.5) shakeIntensity = 0;

        ctx.save();
        if (shakeIntensity > 0) {
            ctx.translate((Math.random()-0.5)*shakeIntensity, (Math.random()-0.5)*shakeIntensity);
        }
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // --- 1. 背景繪製 (星雲與星星) ---
        ctx.save();
        
        // 繪製星雲
        bgParticles.nebulas.forEach(n => {
            n.x += n.vx; n.y += n.vy; // 緩慢移動
            if(n.x < -200) n.x = canvas.width+200;
            if(n.x > canvas.width+200) n.x = -200;
            
            const grad = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.radius);
            grad.addColorStop(0, n.color);
            grad.addColorStop(1, 'transparent');
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(n.x, n.y, n.radius, 0, Math.PI*2); ctx.fill();
        });

        spawnMeteor();
        // 繪製流星
        bgParticles.meteors.forEach((m, i) => {
            m.x += m.vx; m.y += m.vy; m.life -= 0.02;
            ctx.strokeStyle = `rgba(255, 255, 255, ${m.life})`;
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(m.x, m.y); ctx.lineTo(m.x - m.vx*3, m.y - m.vy*3); ctx.stroke();
            if(m.life <= 0) bgParticles.meteors.splice(i, 1);
        });

        // 繪製星星
        bgParticles.stars.forEach(s => {
            s.opacity += s.flicker; if(s.opacity>1||s.opacity<0.2) s.flicker*=-1;
            ctx.globalAlpha = s.opacity; ctx.fillStyle='#fff';
            ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
        });

        if (currentLevelIndex >= 23) {
            ctx.globalCompositeOperation = 'overlay';
            ctx.fillStyle = 'rgba(255, 215, 0, 0.15)';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.globalCompositeOperation = 'source-over';
        }
        ctx.restore();

        // --- 2. 邏輯更新 ---
        
        if (gameState === 'PLAYING' || gameState === 'BOSS') {
            player.x += (player.targetX - player.x) * 0.15;
            player.haloAngle += 0.02;
            if (spreadTimer > 0) spreadTimer -= dt;
            if (freezeTimer > 0) freezeTimer -= dt;
        }

        // 道具更新
        for (let i = items.length - 1; i >= 0; i--) {
            let item = items[i];
            item.y += 3;
            let dx = player.x - item.x; let dy = player.y - item.y;
            if (Math.sqrt(dx*dx + dy*dy) < 50) {
                playSound('powerup');
                if (item.type === 'spread') { spreadTimer = 5000; showFloatingMsg("千手觀音!"); }
                else if (item.type === 'freeze') { freezeTimer = 3000; showFloatingMsg("定!"); }
                else if (item.type === 'shield') { hasShield = true; showFloatingMsg("般若盾!"); }
                items.splice(i, 1);
            } else if (item.y > canvas.height) items.splice(i, 1);
        }

        if (gameState === 'BOSS') {
            checkBossLogic(dt);
            if (boss.weakPoints.every(wp => !wp.active)) {
                boss.active = false;
                boss.defeated = true;
                bossHud.style.display = 'none';
                showFloatingMsg("心魔已除，繼續修行", 'golden');
                triggerShake(30);
                enemies = []; 
                levelComplete(); 
            }
        } 
        else if (gameState === 'PLAYING' && freezeTimer <= 0) {
            spawnTimer += dt;
            let interval = (currentLevelIndex >= 23) ? 200 : spawnInterval; 
            
            if (spawnTimer > interval && waveQueue.length > 0) {
                spawnTimer = 0;
                const data = waveQueue.shift();
                
                const enemyWidth = 70;
                const margin = canvas.width * 0.15; 
                const spawnWidth = canvas.width - (margin * 2) - enemyWidth;
                const spawnX = Math.random() * spawnWidth + margin;

                enemies.push({
                    x: spawnX,
                    y: -50, width: 70, height: 70,
                    char: data.char, idx: data.idx,
                    speed: (canvas.height/15000)*16 * (currentLevelIndex >= 23 ? 3 : 1),
                    wobble: Math.random()*100,
                    angle: 0, rotSpeed: (Math.random()-0.5) * 0.05 // 增加旋轉
                });
            } else if (waveQueue.length === 0 && enemies.length === 0) {
                levelComplete();
            }
        }

        // 敵人更新
        for (let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            if (freezeTimer <= 0) {
                e.y += e.speed;
                if (e.char) e.x += Math.sin((e.y + e.wobble)*0.02)*0.5;
                if (e.rotSpeed) e.angle += e.rotSpeed; // 旋轉
            }

            if (e.y + e.height > player.y - 20 && Math.abs(e.x - player.x) < 40) {
                if (hasShield) {
                    hasShield = false;
                    triggerShake(10); playSound('error'); showFloatingMsg("護盾破碎");
                    enemies.splice(i, 1);
                } else {
                    gameOver("定力不足，心魔入侵");
                    return;
                }
            }
            else if (e.y > canvas.height) {
                if (e.char) { 
                    e.y = -100; 
                    const enemyWidth = 70;
                    const margin = canvas.width * 0.15;
                    const spawnWidth = canvas.width - (margin * 2) - enemyWidth;
                    e.x = Math.random() * spawnWidth + margin;

                    if (currentLevelIndex < 23) { 
                        score = Math.max(0, score - 5); comboCount = 0;
                    }
                    scoreEl.innerText = score; comboEl.innerText = comboCount;
                } else { 
                    enemies.splice(i, 1);
                }
            }
        }

        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            b.x += b.vx || 0; b.y += b.vy; 
            b.trail.push({x:b.x, y:b.y}); if(b.trail.length>5) b.trail.shift();
            if (b.y < -50) bullets.splice(i, 1);
        }

        for (let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            let hit = false;

            if (gameState === 'BOSS' && boss.active) {
                for (let wp of boss.weakPoints) {
                    if (wp.active && Math.hypot(b.x - wp.x, b.y - wp.y) < 40) {
                        wp.active = false; hit = true;
                        createExplosion(wp.x, wp.y, '#ff5252', true);
                        boss.hp -= 34; 
                        bossHpFill.style.width = Math.max(0, boss.hp) + '%';
                        playSound('hit');
                        if (Math.random() > 0.5) items.push({x: wp.x, y: wp.y, type: 'spread'});
                        break;
                    }
                }
            }

            if (!hit) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    let e = enemies[j];
                    if (Math.hypot(b.x - (e.x + 35), b.y - (e.y + 35)) < 40) {
                        hit = true;
                        if (e.type === 'interference') {
                            createExplosion(e.x+35, e.y+35, '#555');
                            enemies.splice(j, 1);
                        } else if (e.idx === currentLevelCharIndex) {
                            comboCount++; playSound('hit', comboCount);
                            score += 100 + (comboCount * 10);
                            currentLevelCharIndex++;
                            
                            floatTexts.push({text: e.char, x: e.x, y: e.y, life: 1.0, scale: 1});
                            
                            if (comboCount % 20 === 0) items.push({x: e.x, y: e.y, type: 'spread'});
                            if (comboCount % 35 === 0) items.push({x: e.x, y: e.y, type: 'freeze'});
                            if (comboCount % 10 === 0 && !hasShield) { hasShield = true; showFloatingMsg("般若盾"); }

                            createExplosion(e.x+35, e.y+35, '#ffd700', true);
                            
                            const span = document.createElement('span'); span.className = 'sutra-char'; span.innerText = e.char; collectedEl.appendChild(span);
                            collectedEl.scrollTop = collectedEl.scrollHeight;

                            enemies.splice(j, 1);
                            updateTarget();
                        } else {
                            if (currentLevelIndex < 23) {
                                comboCount = 0; score -= 10; playSound('error');
                                triggerShake(5);
                                createExplosion(e.x+35, e.y+35, '#ff5252');
                            } else {
                                createExplosion(e.x+35, e.y+35, '#ffd700');
                                enemies.splice(j, 1);
                            }
                        }
                        scoreEl.innerText = score; comboEl.innerText = comboCount;
                        comboEl.style.transform = `scale(${1 + Math.min(comboCount*0.1, 1)})`;
                        setTimeout(()=>comboEl.style.transform='scale(1)', 100);
                        break;
                    }
                }
            }
            if (hit) bullets.splice(i, 1);
        }

        // --- 3. 繪製 ---
        
        // 只在非首頁時繪製遊戲物件
        if (gameState !== 'START') {
            items.forEach(item => {
                let img = (item.type === 'spread') ? spreadImg : freezeImg; 
                ctx.drawImage(img, item.x-20, item.y-20, 40, 40);
            });

            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.haloAngle);
            // 光環稍微增強
            ctx.strokeStyle = `rgba(255, 215, 0, ${hasShield ? 0.9 : 0.4})`;
            ctx.lineWidth = hasShield ? 5 : 3;
            ctx.beginPath();
            for(let k=0; k<8; k++) { ctx.moveTo(0,0); ctx.lineTo(60,0); ctx.rotate(Math.PI/4); }
            ctx.stroke();
            ctx.beginPath(); ctx.arc(0,0,55,0,Math.PI*2); ctx.stroke();
            if (hasShield) {
                ctx.fillStyle = 'rgba(255, 64, 129, 0.4)';
                for(let k=0; k<6; k++) { ctx.rotate(Math.PI/3); ctx.beginPath(); ctx.ellipse(0, -60, 10, 30, 0, 0, Math.PI*2); ctx.fill(); }
            }
            ctx.restore();
            ctx.drawImage(playerImg, player.x-32, player.y-32, 64, 64);

            ctx.globalCompositeOperation = 'lighter';
            bullets.forEach(b => {
                if (b.trail.length) {
                    ctx.strokeStyle = 'rgba(255,255,0,0.5)'; ctx.lineWidth=10;
                    ctx.beginPath(); ctx.moveTo(b.trail[0].x, b.trail[0].y);
                    b.trail.forEach(t=>ctx.lineTo(t.x, t.y)); ctx.stroke();
                }
                ctx.drawImage(bulletImg, b.x-16, b.y-16, 32, 32);
            });
            ctx.globalCompositeOperation = 'source-over';

            enemies.forEach(e => {
                ctx.save();
                ctx.translate(e.x + 35, e.y + 35); // 中心點
                if (e.angle) ctx.rotate(e.angle); // 旋轉
                
                if (e.type === 'interference') {
                    ctx.fillStyle = '#ff1744'; ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI*2); ctx.fill();
                } else {
                    ctx.drawImage(enemyImg, -35, -35, 70, 70);
                    // 目標提示框
                    if (e.idx === currentLevelCharIndex) {
                        ctx.strokeStyle = '#ffd700'; ctx.lineWidth=3;
                        let scale = 1 + Math.sin(timestamp*0.01)*0.1;
                        ctx.scale(scale, scale);
                        ctx.beginPath(); ctx.arc(0, 0, 38, 0, Math.PI*2); ctx.stroke();
                        ctx.scale(1/scale, 1/scale);
                    }
                    
                    // 為了讓字體不跟著轉太暈，字體可以反向轉回來，或者就跟著轉(更有動感)
                    // 這裡選擇讓字體跟著轉，因為隕石也在轉
                    ctx.font = "bold 30px 'Ma Shan Zheng'"; ctx.textAlign="center"; ctx.textBaseline="middle";
                    ctx.fillStyle = (e.idx === currentLevelCharIndex) ? '#ffd700' : '#ddd';
                    // 陰影增加清晰度
                    ctx.shadowColor = 'black'; ctx.shadowBlur = 4;
                    ctx.fillText(e.char, 0, 3);
                }
                ctx.restore();
            });

            if (gameState === 'BOSS' && boss.active) {
                ctx.save();
                ctx.translate(boss.x, boss.y);
                // Boss 增加呼吸效果
                let bossScale = 1 + Math.sin(timestamp * 0.005) * 0.05;
                ctx.scale(bossScale, bossScale);
                
                ctx.fillStyle = 'rgba(20, 0, 0, 0.8)';
                ctx.shadowColor = '#d50000'; ctx.shadowBlur = 40;
                ctx.beginPath(); ctx.arc(0, 0, 80, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#ff1744';
                ctx.beginPath(); ctx.ellipse(-30, -10, 10, 20, 0.2, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.ellipse(30, -10, 10, 20, -0.2, 0, Math.PI*2); ctx.fill();
                ctx.restore();

                boss.weakPoints.forEach(wp => {
                    if (wp.active) {
                        ctx.save();
                        ctx.translate(wp.x, wp.y);
                        ctx.beginPath(); ctx.arc(0, 0, 30, 0, Math.PI*2);
                        ctx.fillStyle = '#111'; ctx.fill();
                        ctx.strokeStyle = '#ff1744'; ctx.lineWidth=3; ctx.stroke();
                        ctx.fillStyle = '#ff1744'; ctx.font="30px 'Ma Shan Zheng'";
                        ctx.textAlign="center"; ctx.textBaseline="middle";
                        ctx.fillText(wp.text, 0, 0);
                        ctx.restore();
                    }
                });
            }

            for (let i = floatTexts.length - 1; i >= 0; i--) {
                let ft = floatTexts[i];
                ft.life -= 0.04; // 稍微慢一點消失
                if (ft.life <= 0) { floatTexts.splice(i, 1); continue; }
                ctx.save();
                ctx.translate(ft.x + 35, ft.y + 35);
                let s = 1 + (1-ft.life) * 0.5; 
                ctx.scale(s, s);
                ctx.globalAlpha = ft.life;
                ctx.fillStyle = '#ffd700';
                ctx.shadowColor = '#ff6f00'; ctx.shadowBlur = 20;
                ctx.font = "bold 60px 'Ma Shan Zheng'";
                ctx.fillText(ft.text, 0, 0);
                ctx.restore();
            }
        }

        particles.forEach((p, i) => {
            p.life -= 0.05; p.x += p.vx; p.y += p.vy;
            ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
            if (p.life<=0) particles.splice(i,1);
        });
        ctx.globalAlpha = 1.0;
        ctx.restore(); 

        requestAnimationFrame(gameLoop);
    }

    function createExplosion(x, y, color, big=false) {
        for(let i=0; i<(big?30:10); i++) {
            particles.push({
                x:x, y:y, vx:(Math.random()-0.5)*10, vy:(Math.random()-0.5)*10,
                life:1, color:color, size:Math.random()*5+2
            });
        }
    }

    function winGame() {
        gameState = 'GAMEOVER';
        bgmPlayer.pause(); // 遊戲結束停止 BGM
        document.getElementById('end-title').innerText = "功德圓滿";
        document.getElementById('end-reason').innerText = "心無罣礙，究竟涅槃";
        document.getElementById('final-score').innerText = score;
        gameOverScreen.style.display = 'flex';
    }

    function gameOver(reason) {
        gameState = 'GAMEOVER';
        bgmPlayer.pause(); // 遊戲結束停止 BGM
        document.getElementById('end-title').innerText = "修行未果";
        document.getElementById('end-reason').innerText = reason;
        document.getElementById('final-score').innerText = score;
        gameOverScreen.style.display = 'flex';
    }

    // 啟動動畫迴圈 (讓首頁能顯示流星)
    resize();
    requestAnimationFrame(gameLoop);

</script>
</body>
</html>